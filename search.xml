<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo主题模版改造记录]]></title>
    <url>%2Fposts%2F31380.html</url>
    <content type="text"><![CDATA[有时候就是心血来潮才想搞一些好玩的，假期一旦懒下来人就待完了。 上一篇: hexo主题迁移and折腾记 开始之前一直是抱着小小改造一下将就用就行了的心态来改造博客主题，直到又一个朋友也开始建立博客。于是一直懒着不愿意写的友链以及关于的独立页面也不得不提上日程，就连之前想加入的 clipboard.js 这次也想一股气做好。说起来容易，实际开始读 layout 部分代码才发现自己并不是很懂整个 pug 模版的渲染流程以及构架。整个博文是对于改造过程的记录，如果嫌烦可以跳过我思考的那一部分。 思考最初搜索一番，仍然发现大多数就是简单的建立一个友链的 page 然后直接 md 堆上去就完事了。当然我之前也这么做过。但是实际效果并不尽如人意。于是不得不进行主题拆解。 然后花费了相当长一段时间发现并没有搞懂主题的布局…Orz。这就产生了一个问题，在寻找了非常多 HEXO 主题开发相关的博文时候，发现不管是用脚手架来搭建还是怎样，一个主题一定是先有布局再往里面填肉，虽然日常自己写点东西是这个思想却没想到用这个思想来解构，有点呆。 解构主题所以，整体布局确实如下图，从代码中也多少能看出点倪端： 那么看下整体文件的解构： 123456789101112131415161718192021222324252627282930themes/maupassant/layout/----------------------------------├── archive.pug├── base.pug├── index.pug├── page.pug├── post.pug├── single-column.pug├── timeline.pug├── _partial ├── after_footer.pug ├── comments.pug ├── footer.pug ├── head.pug ├── helpers.pug ├── mathjax2.pug ├── mathjax.pug ├── paginator.pug ├── post_nav.pug ├── tag.pug ├── totop.pug └── wordcount.pug|── _widget ├── category.pug ├── links.pug ├── recent_comments.pug ├── recent_posts.pug ├── search.pug ├── tag.pug └── toc.pug 如果是仔细阅读过主题配置文件，就会发现其中下面列出的这一部分就属于我们说的“单独的页面”： 1234├── index.pug├── timeline.pug├── post.pug├── archive.pug 这些是主题中最最基础的几个独立页面：文章、时间线、主页、文章归档。 其中都会有那么句： 123extends base...include _partial/BALABALA.pug 如果是对编程相对熟悉的同学可能一下子就发现了这不是典型的引入么，前面是以 base.pug 作为“母版”，后面在上面加东西。前面尝试着 copy 过别人的代码尝试添加一个侧边栏的 TOC（以失败告终），但是并没有好好阅读代码，所以这次吃了大苦头。所以，就连其他全部页面都是在 base 基础上扩展来的，因此提供了一个思路：要想添加自己的独立页面，就需要仿照其他的从 base 为基础进行扩展。 那么我们来看一下，比如这个 archive: 1234567891011121314151617181920212223242526archive.pug-------------------extends baseblock title if page.category title= page.category + ' | ' + config.title if page.tag title= page.tag + ' | ' + config.title if page.archive title= __('archive') + ' | ' + config.titleblock content if page.category || page.tag h1.label-title= __('reading_label', page.category || page.tag) .post .post-archive //Use lodash to classify posts. See https://lodash.com/docs#groupBy each posts, year in _.groupBy(page.posts.toArray(), function(p)&#123;return -p.date.format('YYYY')&#125;) h2= -year ul.listing for post in posts li span.date= post.date.format(config.date_format) a(href=url_for(post.path), title=post.title) +title(post) include _partial/paginator.pug 可以发现整个结构如下： 1234567extends baseblock title..........block content........ 正好也符合整个页面的布局。那么，友链那么多条是不是要自己一条条加上去呢？傻子才全手写。 _widget/links.pug 中就很好的提到了一个思路，当然也非常常用：用 for 循环 123- for (var i in theme.links) ul a(href=theme.links[i].url title=theme.links[i].title target='_blank') #&#123;theme.links[i].title&#125; 不过可以发现少了一些东西，头像呢？描述呢？其实这些东西自己加上就好，这里不赘述 YAML 的语法，整个过程相当是从themes/_config.yml 中取出 links部分的值，然后找寻每个 links 部分的的子项，这是个很好的思路。 动工首先现在themes/_config.yml填入所需值，然后编写独立页面： 1234567891011121314151617181920layout/single-link-page.pug-------------------------------------extends baseblock title title= page.title + ' | ' + config.titleblock content - for (var i in theme.links) p a.friendurl(target='_blank', href=theme.links[i].url, title=theme.links[i].title) a.friendurl(target='_blank', href=theme.links[i].url, title=theme.links[i].title) .frienddiv a.frienddivleft(target='_blank', href=theme.links[i].url) img.myfriend(src=theme.links[i].src) // 头像部分 .frienddivright | #&#123;theme.links[i].title&#125; br br | #&#123;theme.links[i].dec&#125; // 描述 样式网上有非常多，不愿意写可以找一找抄一抄（虽然有无脑抄完回来给我留言说编译失败的….）。有点前端基础自己写就好，这种东西不怎么依赖定位倒也是好写。 然后出现一个问题：侧边栏影响美观程度。解决方法是仿照 base 写一个无侧边栏的即可（其实就是把 sidebar 对应部分注释掉），相对的，开头 extends 的部分也要进行修改。 （未完待续） http://www.codeblocq.com/2016/03/Create-an-Hexo-Theme-Part-2-Other-Pages/ https://hqcfly.github.io/2016/06/19/hexo-theme-guide/ https://molunerfinn.com/make-a-hexo-theme/ http://huanyouchen.github.io/2019/03/22/add-tags-pages-to-hexo-maupassant-theme/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>模版</tag>
        <tag>响应式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用zenity+xclip实现文字复制粘贴]]></title>
    <url>%2Fposts%2F5960.html</url>
    <content type="text"><![CDATA[都多久了我也不太记得，网易云下竟然由于qt的某个问题不能使用fcitx输入中文了！WTF！不过我们可以曲线救国。 就算直接不能输入中文我们也有办法暂时解决这个问题。那就是使用zenity+xclip制作一个可输入中文的带有 GUI 的一个脚本。 xclip是Unix以及类Unix系统下非常强大的剪贴板交互程序 我们可以简单看一下xclip的help输出： 123456789101112131415161718Usage: xclip [OPTION] [FILE]...Access an X server selection for reading or writing. -i, -in read text into X selection from standard input or files (default) -o, -out prints the selection to standard out (generally for piping to a file or program) -l, -loops number of selection requests to wait for before exiting -d, -display X display to connect to (eg localhost:0") -h, -help usage information -selection selection to access ("primary", "secondary", "clipboard" or "buffer-cut") -noutf8 don't treat text as utf-8, use old unicode -target use the given target atom -rmlastnl remove the last newline charater if present -version version information -silent errors only, run in background (default) -quiet run in foreground, show what's happening -verbose running commentary 按照功能，我们需要： 输入文字 将文字输入到剪贴板 将文字传给clipboard程序 非常简单的三个部分。输入文字部分由zenity负责，同时将输入的文字存入变量中，之后用管道传给xclip程序。 那么需要用到的xclip选项应该就很容易选择了。 123# xclip optionxclip -i # read text into X selection from standard input or filesxclip --selectron clipboard # copy input to clipboard for output 思路明确了以后就非常容易办了，我们再看一下zenity entry部分的帮助说明： 12345678用法： zenity [OPTION…]文字输入选项 --entry 显示文本输入对话框 --text=文字 设置对话框文字 --entry-text=文字 设置输入文字 --hide-text 隐藏输入文字 也就是说我们只需要使用 --entry 选项显示输入框即可，在尝试中发现，bash下执行zenity –entry后会将输入打印到终端，也就是说我们需要将其存为变量才可以使用。因此完整代码如下： 12345#!/bin/bashwords_to_copy=$(zenity --entry)# Use zenity to display a GUI information message.echo $words_to_copy | xclip -i echo $words_to_copy | xclip -sel c]]></content>
      <categories>
        <category>archlinux</category>
      </categories>
      <tags>
        <tag>zenity</tag>
        <tag>xclip</tag>
        <tag>去他妈的网易云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用nodejs+shellscript实现github-webhook]]></title>
    <url>%2Fposts%2F41471.html</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>webhook</tag>
        <tag>nodejs</tag>
        <tag>自动化流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[archlinux安装配置(3)]]></title>
    <url>%2Fposts%2F12422.html</url>
    <content type="text"><![CDATA[距离第一篇博文时隔快两年的更新。由于本次配置文件有问题，KDE直接罢工。修补无果于是决定重装。 前文： 基础系统安装 基础系统配置 前言本文将会涉及到的内容： 相当个人级别的系统配置 可能非常不符合常理的做法 可能涉及到的错误 如果是第一次或者还没安装的话可以先按照正经的步骤进行安装以避免误导。 chroot下的变更在正常的安装流程下，我增加安装了几个包： 1pacman -S fish iw dialog dhcp wpa_supplicant vim sudo screenfetch htop 将其分为几类： shell: fish(开箱即用的强大shell) network: iw dialog wpa_supplicant dhcp(保证进入新系统有网) editor: vim(个人非常喜欢的编辑器，更改sudoer会强制使用) tools: htop sudo screenfetch(强大的进程管理器、提权工具、基础信息查看) 这样的话进入新系统会节省一部分时间。 新系统下的更改用户由于我是重新安装系统，因此/home还在，因此没必要按照常规的在新建用户时候添加-m选项： 1useradd username 1passwd username 这样的话就完成了用户建立（并且使用旧的/home）。 网络因为之前配置完了大部分的内容，因此进入系统的第二件事是先联网。这里使用的是netctl,稍后再更换为NetworkManager。 因为是wifi链接，所以执行： 1wifi-menu 然后连接到自己需要的网络。由于个人的路由器是限制设备ip的，因此需要在设备上填入固定IP才能正常联网。虽然上一步执行后失败，但是此时netctl已经有了需要的配置文件。形如： 1234567891011# /etc/netctl/wlp2s0-wifi------------------------------------------------------------------------------------------------Description='Automatically generated profile by wifi-menu'Interface=wlp2s0Connection=wirelessSecurity=wpaESSID= #WiFi名称IP=staticAddress=() #指定的IPGateway= #网关，不知道怎么确定的就填写192.168.1.0一般没问题Key= #密码 当然这个是修改过的，然后执行： 1netctl start wlp2s0-wifi 来连接到这个Wifi，并使用： 1netctl status wlp2s0-wifi 查看连接状况。 这样的话应该是有网络了。 包管理按照个人喜好，我比较习惯把包管理的颜色打开，便于区分包。 1234567891011121314151617# /etc/pacman.conf-----------------------------------------------------------------------------------# Misc options部分#UseSyslogColor #取消注释#TotalDownloadCheckSpaceVerbosePkgLists #取消注释，更新时可看到变动信息# 32位的东西有时候不可避免，为了不必要的麻烦需要打开[multilib]Include = /etc/pacman.d/mirrorlist# 添加ArchlinuxCN仓库[archlinuxcn]SigLevel = TrustedOnlyServer = http://mirrors.cqu.edu.cn/archlinuxcn/$arch 之后需要执行： 12pacman -Syy #更新本地包管理的数据库pacman -S archlinuxcn-keyring #添加archlinuxCN的签名，主要是为了安全，大概 桌面环境安装一般来讲选KDE还是选gnome这个确实看眼缘。由于gnome上个版本的内存泄露太邪门了，虽然目前已经修好但是我还是用KDE吧。 安装KDE的话一般可能会推荐安装整个Plasma套件，但是好多东西其实用不到，因此也没必要装。我还是决定从最基础的plasma desktop 开始像搭积木一样配置好。 先安装最基础的桌面环境： 1pacman -S plasma-desktop 然后我们装一下驱动，我是intel核显加上A卡独显，不怎么麻烦，并且A卡先不打算用，入门级性能弱的要死也没办法用： 1pacman -S xf86-video-intel 一般这样的话 I 卡就可以正常工作了。然后安装桌面管理器SDDM： 12pacman -S sddmsystemctl enable sddm #添加sddm开机启动 因为我们进入桌面环境以后还需要进行配置，因此终端以及文件管理器是必须的： 1pacman -S konsole dolphin 然后重启进入KDE。 剩余桌面环境配置进入桌面环境以后就都属于比较常规的配置了，依照个人喜好进行配置就好。 仍然是系统组件部分一般来讲的话我们的桌面目前已经可以使用了，但是为了一些更加方便的调整我们需要安装一些KDE设置中心的插件。 1pacman -Ss kcm 不出意外的话应该得到如下结果： 123456789101112131415161718extra/kcmutils 5.60.0-1 (kf5) Utilities for interacting with KCModulesextra/sddm-kcm 5.16.3-1 (plasma) KDE Config Module for SDDMextra/telepathy-kde-accounts-kcm 19.04.3-1 (kde-applications kdenetwork telepathy-kde) KCM Module for configuring Telepathy Instant Messaging Accountscommunity/kcm-fcitx 0.5.5-2 KDE Config Module for Fcitxcommunity/kcm-wacomtablet 1:3.1.1-1 KDE GUI for the Wacom Linux Driversarchlinuxcn/kcm-colorful-git 1.0.1.r0.g2cb0524-1 Make your KDE plasma colorfularchlinuxcn/kcm-fcitx5-git r240.62e087f-2 KDE Config Module for Fcitx5archlinuxcn/nx-firewall-git 0.1.r70.gdf134bd-1 Firewall KCM: Plasma 5 Firewall KCM.archlinuxcn/systemd-kcm 1.2.1-4 Systemd control module for KDE 挑选我们喜欢的组件安装即可。 另外，由于对于显示部分以及触控板都有额外组件可以用，参照ArchLinux的wiki来一个个安装就可以了，比如相当常用的两个： 1kscreen libinput 这部分完全是各取所需，另外比如axel等命令行工具也是可以根据需求安装的。 美化部分]]></content>
      <categories>
        <category>archlinux</category>
      </categories>
      <tags>
        <tag>archlinux</tag>
        <tag>linux</tag>
        <tag>完全配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用pandoc撰写论文]]></title>
    <url>%2Fposts%2F1448.html</url>
    <content type="text"><![CDATA[前言谁又说不可以呢？ 引言一般论文写作等会有如下痛点，包含： 数学公式 图片处理 交叉引用、脚注、尾注 参考文献的文献库处理 当然大名鼎鼎的Microsoft Office当然能处理这些问题，但是与其说是能处理，不如说是处理的不当就会变得麻烦起来。在这些方面处理的最好的应该是LaTeX，但是由于其语法学习曲线非常陡峭，那么支持部分LaTeX特性的Markdown将是比较好的选择，处理得当时将包含如下特性： 基于自然语言的数学公式处理 HTML支持，意味着markdown的写作可以很灵活多变 插件扩展的的流程图、甘特图、美人鱼图支持 交叉引用、脚注、尾注、文献自动插入 目录自动生成 那么本文将简要的介绍下如何使用markdown来进行基本的写作。 注：本文内容相对较多，但是请相信看完之后收获会是巨大的。 相关概念Markdown Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown具有一系列衍生版本，用于扩展Markdown的功能（如表格、脚注、内嵌HTML等等），这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown增强版中比较有名的有Markdown Extra、MultiMarkdown、 Maruku等。这些衍生版本要么基于工具，如Pandoc；要么基于网站，如GitHub和Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。[^2][@noauthor_markdown__nodate] 看到这里很懵是不是？但是如果换种说法：DOC格式和markdown本是同根生，是不是就容易多了？DOC所有关键信息等均使用XML格式，而这个格式和markdown其实本质类似。区别是： （图片） 哪个易读性更好一看便知。用markdown你能做什么？ 记笔记 写网页 其他 markdown编辑器推荐Typora（全平台）所见即所得，只有用过的才知道多好用。功能最全。但是不能进行扩展。其实已有的功能已经非常够用了。 Mu（Mac OS）同样所见即所得，但是功能性比Typora弱。 Atom 或者 Visual Studio Code（全平台）伪装成IDE的文本编辑器，一般程序员以及编程爱好者无人不知，有巨量的插件扩展。能玩游戏看B站听歌聊QQ微信微博。摸鱼神器。 pandoc Pandoc是由John MacFarlane开发的标记语言转换工具，可实现不同标记语言间的格式转换，堪称该领域中的“瑞士军刀”。Pandoc使用Haskell语言编写，以命令行形式实现与用户的交互，可支持多种操作系统。[^3][@noauthor_pandoc_2017] 那么它能处理的格式到底有多少种： （图片） 图片上一个节点代表它能处理的一种格式。 富文本 富文本格式（Rich Text Format, 一般简称为RTF）是由微软公司开发的跨平台文档格式。一般的格式设置，比如字体和段落设置，页面设置等等信息都可以存在RTF格式中。[^1][@noauthor___nodate] 这是狭义上的富文本，那么广义上的富文本是什么呢？就是所谓的当你编辑时所见即所得。没有谁希望编辑一个文件时还需要像二十年前一样还需要修修改源代码的吧？因此富文本及富文本编辑器的发明是非常重要的革新。但是这是不是意味着纯文本会消失呢？并不。富文本有着富文本的易用，纯文本有着纯文本的轻便。至少来讲，我可不希望在写作前写作后还需要花费大量时间插入参考资料或者调整文本的排版字体大小还是怎样。尤其在写作中如果遇到需要处理的图片，大部分人应该是相当头痛的——既需要照顾排版又不不希望切断思路。那么对于大多数只用到了Microsoft Office Word以及OneNote基础功能的人来说无论使用什么来编辑文档其实都差不了多少。 语法Markdown基础请不要把markdown视为非常可怕的东西。其实它非常容易掌握，而且对于使用者很友好——因为你在写作时的思路不会被打断，所有格式使用的语法非常简洁并全部可以通过一些文本实现。 在使用之前，为了方便书写请确保你的输入法是处于半角状态（搜狗上是月牙和圆点，月牙为半角；微软拼音在设置里调整），使用半角输入会将你的输入速度无论是在是用什么都会提高一个等级。 标题类Markdown的标题很容易表示： 123# 这是一级标题## 这时二级标题### 这是三级标题 每多一级标题就可以增加一个“#”。具体支持到哪级目录需要看渲染工具的支持，理论上无限。 注意：为了使格式生效请在“#”后记得加个空格 标注类文本上的标注1234*斜体* **加粗*****加粗的斜体***&lt;u&gt;下划线&lt;/u&gt; 当然你也可以使用下划线替换“*”，效果是一样的。 文内引用1234代码：​```你的代码语言echo helloworld;​ 脚注：这是一段实例文字。[^1][^1]: 这是实例文字的脚注，在生成的Word文档中会自动放置 尾注：这是一段实例文字。[@example P33 Weearc]Reference:(自动生成，不需要动它) 下标：~下标~ 段落引用： 你要引用的段落 说明：引用完成时请多加一个回车（换行符），引用时尖括号后需要空格123456789以上是Markdown的基础语法部分，和普通六级专八词汇相比应该是简单的不是一星半点吧。### 链接类#### 图片```markdown![图片的说明](图片位置) 链接1![链接的说明文字](链接) markdown进阶表格类基本表格（不含单元格合并）基本的一个三乘三表格 1234|title1|title2|title3||:-----|:----:|-----:||左侧对齐|居中|右侧对齐||x|y|z| 生成效果如下： title1 title2 title3 左侧对齐 居中 右侧对齐 x y z HTML表格（包含单元格合并的）1234567891011121314151617181920&lt;table&gt; &lt;tr&gt; &lt;td&gt;列一&lt;/td&gt; &lt;td&gt;列二&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt;合并行&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;列一&lt;/td&gt; &lt;td&gt;列二&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan="2"&gt;合并列&lt;/td&gt; &lt;td &gt;行二列二&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td &gt;行三列二&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 效果： 列一 列二 合并行 列一 列二 合并列 行二列二 行三列二 公式类此节主要包含数学公式，使用LaTeX数学公式语法。 上标123$x^n$ 生成为：$x^n$ 下标123$C^2_3$ 选择数： $C^2_3$ 多项式一个不包含tag的多项式 123456$T(n)=\begin&#123;cases&#125;\Theta(1)\quad n=1\\T(n-q)+\Theta(n) \quad n&gt;1\end&#123;cases&#125;$ 那么生成的公式如下： $T(n)=\begin{cases}\Theta(1)\quad n=1\T(n-q)+\Theta(n) \quad n&gt;1\end{cases}$ 矩阵及行列式一个包含tag的矩阵[@noauthor_markdown_nodate-1] 1234567$ \begin&#123;bmatrix&#125; 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \end&#123;bmatrix&#125; \tag&#123;1&#125;$ $$\begin{bmatrix} 1 &amp; 2 &amp; 3 \ 4 &amp; 5 &amp; 6 \ 7 &amp; 8 &amp; 9 \ \end{bmatrix} \tag{1}$$ 公式123$J(\theta) = \frac&#123;1&#125;&#123;2m&#125;\sum_&#123;i=0&#125;^m(y^i - h_\theta(x^i))^2$ 生成的均方差公式为： $J(\theta) = \frac{1}{2m}\sum_{i=0}^m(y^i - h_\theta(x^i))^2$ 还有很多…LaTeX的数学公式异常灵活，其余语法可以自行查阅。 信息类YAML样式的信息12345---title: 这是一个标题time: 2019TOC: true--- 那么将生成自动目录以及包含时间信息的文章标题部分。 XML样式信息如果你更熟悉XML，直接上吧骚年！ 导图类使用markdown可以通过公式方式扩展来写流程图等。[@noauthor_typora__nodate] 甘特图(时序图)12345678910111213​```mermaid sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好!​ 12345678910111213141516171819202122232425262728```mermaid%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头 sequenceDiagram participant 张三 participant 李四 张三-&gt;王五: 王五你好吗？ loop 健康检查 王五-&gt;王五: 与疾病战斗 end Note right of 王五: 合理 食物 &lt;br/&gt;看医生... 李四--&gt;&gt;张三: 很好! 王五-&gt;李四: 你怎么样? 李四--&gt;王五: 很好! 美人鱼图一个示例的美人鱼图： 123456789​```mermaidgraph TDclient1--&gt;|read / write|SVN((SVN server))client2--&gt;|read only|SVNclient3--&gt;|read / write|SVNclient4--&gt;|read only|SVNclient5(...)--&gt;SVNSVN---|store the data|sharedrive​ 123456789```mermaidgraph TDclient1--&gt;|read / write|SVN((SVN server))client2--&gt;|read only|SVNclient3--&gt;|read / write|SVNclient4--&gt;|read only|SVNclient5(...)--&gt;SVNSVN---|store the data|sharedrive 此处参考 与文献管理工具互动为什么不推荐使用word自带的文献管理器，因为Zotero以及Mandelay等文献管理器更加强大而且易用，包含比如PDF阅读、文献检索、文献关联设置、关键词等。 这里只对zotero文献管理器与markdown论文撰写的互动进行说明。 Zotero首先到Zotero官网下载软件本体进行安装，然后按照提示安装浏览器插件。使用如下图： （gif） 之后你可以在Zotero导出参考文献。导出时请选择Bibtex格式。需要生成参考文献时直接将导出的文件用文本编辑器打开并进行如下操作： 12345#一个实例的bib文件内容@misc&#123;noauthor_britains_nodate, title = &#123;Britain’s imperial fantasies have given us &#123;Brexit&#125; &#123;\textbar&#125; &#123;Gary&#125; &#123;Younge&#125; &#123;\textbar&#125; &#123;Opinion&#125; &#123;\textbar&#125; &#123;The&#125; &#123;Guardian&#125;&#125;, url = &#123;https://www.theguardian.com/commentisfree/2018/feb/03/imperial-fantasies-brexit-theresa-may&#125;, urldate = &#123;2019-04-29&#125; 1这里引用了参考[@noauthor_britains_nodate] 即将包含“@misc”行行首大括号后内容前加“@”用中括号“[]”包裹放在需要引用的位置。生成文件时会自动在文末添加参考文献。[@noauthor_markdown_nodate] 使用pandoc生成（最后一步了）pandoc安装WindowsWindows用户可以再官网下载EXE文件进行安装，并安装Python3使用pip安装pandoc的其他扩展。 Mac OSMac用户可以使用brew来安装pandoc，并使用pip来添加扩展 Linux重点说一下Linux，以证明使用Linux同样可以撰写论文。 大多数Linux发行版的仓库内包含pandoc，并默认有pip。使用pip可安装扩展。 对于Arch LinuxArch Linux仓库中为pandoc以及LaTeX全部扩展进行了打包，直接安装，舒适便捷。 生成方式在此文中，我们需要使用的插件为：pandoc-citeproc。 那么使用如下指令生成： 1pandoc --filter pandoc-citeproc --bibliography=你的文献库.bib --csl=chinese-gb7714-2005-numeric.csl 你的markdown文件.md -o 你的生成文件.docx 其中“–csl”选项为需要生成参考文献的具体格式标准。 如果你单单只使用： 1pandoc markdown文件.md -o 生成的文件 将只进行最基础的文件渲染，比如转换为PDF格式。 参考文献（示例）[^1]: https://baike.baidu.com/item/%E5%AF%8C%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F/1017816?fr=aladdin 富文本格式[^2]: https://baike.baidu.com/item/markdown/3245829?fr=aladdin markdown[^3]: https://zh.wikipedia.org/wiki/Pandoc Pandoc]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>pandoc</tag>
        <tag>zotero</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo主题迁移and折腾记]]></title>
    <url>%2Fposts%2F6009.html</url>
    <content type="text"><![CDATA[老实说，其实为什么突然又开始折腾折腾主题了呢…….因为用NexT的人实在太多了。而我又不想让别人打开发现“和某个某个人的很像”。那样就失去了折腾的必要。因此我决定切换主题。另：本文在调整的相对安逸之前会持续更新。 这个目标主题Maupassant，也是早就看上的，但是考虑到next实在太方便了才没能有勇气换过去。直到最近假期才敢小小的折腾一下。在这里感谢一下将这个主题移植到hexo博客系统的大大。如果有机会的话我要尝试把它移植到HUGO上看看。稍微小小的看了一下，虽然用的人很多。但是因为结构不算复杂，而且pug格式也方便和纯HTML进行转换，因此可以随时随地添加自己喜欢的插件，把博客改造成自己中意的样子。接下来尽可能简单的并详细的介绍下改造以及部署流程。 主体部分hexo部署这个我想既然会看这篇文章的话至少说明回去读hexo的文档吧！但是以防万一还是从基础开始。 首先配置好nodejs环境，这个绝对不会再写了，无论是哪个平台教程都多得很。 1$ yarn add hexo-cli 这样就部署完成了hexo本体。像我一样做过系统迁移的人，可能需要直接在博客工程文件文件夹内执行： 1$ npm install 然后参考文档建立初始站点，此时应该是使用了landscape主题。那么接下来填写好hexo的_config.yml相关内容。这部分的各个参数请直接参考hexo官方介绍。因为几乎都是自然语言，因此并不难处理。 Maupassant主题部署和大多数hexo引擎的主题采用swig格式的模版不同，Maupassant使用的是pug格式的模版，这个之前也说过了。这种格式并没有比起原生HTML来的更有什么优势。但是可以单独罗列各个部分组件可以更方便的互相拼凑。 按照README，执行一下命令进行部署（我权当此时你仍在工程文件的根目录下）： 123$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ yarn add hexo-renderer-pug$ yarn add hexo-renderer-sass 此时hexo应该有能力渲染pug模版的页面了。 接下来仍然是根据自己需求修改_config.yml文件。这部分也没什么好说的。 开始魔改为什么说是魔改，因为都是只涉及到前端所需要的代码，相对容易修改和调试，只要稍花点心思就可以调整成自己想要的样子。 修改永久链接&amp;添加评论首先是修改评论系统。之前已知使用Disqus!作为评论系统的，但是由于众所周知的原因，这货并没想象的那么棒，那么需要一个相对折中的方案。最开始想选择更为流行的Gitment，但是作者服务器到期了，因此更换为GitTalk。如果只是简单的添加评论系统的话并不能称得上是魔改。如果各位仔细观察的话会发现hexo的文章链接形式都是时间+文章名，这样就难免出现比如中文标题的文章不能初始化评论的问题。 因此这时候需要用到这款插件：hexo-abbrlink。主要作用是将原本非常长的文章链接修改成比较短的、数字加字母的随机生成的链接。 执行： 1$ yarn add hexo-abbrlink 添加该插件。然后修改站点的_config.yml： 添加内容： 1234#abbrlinkabbrink: alg: crc32 rep: dec 并修改永久链接样式： 1permalink: posts/:abbrlink.html 这时候重新生成饮下会发现所有文章链接变成了相对短的链接。而且这款插件会在生成新post时候自动添加选项。非常方便。如果不放心的话可以修改post模版文件。 修改文章文件名为什么要单列出来这个，因为我们有了addrlink这个好东西。但是无论是用什么来管理文章的话，如果全部是带有下划线或者短杠的文件名的话并不利于管理。因此修改站点配置文件_config.yml： 1new_post_name: :year-:month-:day-:title.md # File name of new posts 添加进度条效果这个其实应该是不算难的。因为只涉及到修改CSS部分以及引入pace.js。 注：以下全部都涉及到主题模版的修改，请全部在主题文件夹进行 修改head.pug： 12345678910111213141516 //- 插入进度条 script(src='//cdn.bootcss.com/pace/1.0.2/pace.min.js') link(href='//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css', rel='stylesheet') style. .pace .pace-progress &#123; background: #1abc9c; height: 3px; &#125; .pace .pace-progress-inner &#123; box-shadow: 0 0 10px #1abc9c, 0 0 5px #1abc9c; &#125; .pace .pace-activity &#123; border-top-color: #1abc9c; border-left-color: #1abc9c; &#125;//- 插入进度掉end 如果实在是无法手写pug的话可以先考虑写成HTML再用转换工具进行转换。 添加点击的烟花效果同样修改head.pug，添加如下行： 123456//- 烟花点击效果 if theme.fireworks canvas.fireworks(style='position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;') script(type='text/javascript', src='//cdn.bootcss.com/animejs/2.2.0/anime.min.js') script(type='text/javascript', src='/js/fireworks.js')//- 烟花点击效果end 在source/js/下添加fireworks.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364"use strict";function updateCoords(e) &#123; pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e) &#123; var t = anime.random(0, 360) * Math.PI / 180, a = anime.random(50, 180), n = [-1, 1][anime.random(0, 1)] * a; return &#123; x: e.x + n * Math.cos(t), y: e.y + n * Math.sin(t) &#125; &#125;function createParticule(e, t) &#123; var a = &#123;&#125;; return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos = setParticuleDirection(a), a.draw = function() &#123; ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill() &#125;, a &#125;function createCircle(e, t) &#123; var a = &#123;&#125;; return a.x = e, a.y = t, a.color = "#F00", a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function() &#123; ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth = a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1 &#125;, a &#125;function renderParticule(e) &#123; for (var t = 0; t &lt; e.animatables.length; t++) &#123; e.animatables[t].target.draw() &#125; &#125;function animateParticules(e, t) &#123; for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) &#123; n.push(createParticule(e, t)) &#125; anime.timeline().add(&#123; targets: n, x: function(e) &#123; return e.endPos.x &#125;, y: function(e) &#123; return e.endPos.y &#125;, radius: 0.1, duration: anime.random(1200, 1800), easing: "easeOutExpo", update: renderParticule &#125;).add(&#123; targets: a, radius: anime.random(80, 160), lineWidth: 0, alpha: &#123; value: 0, easing: "linear", duration: anime.random(600, 800) &#125;, duration: anime.random(1200, 1800), easing: "easeOutExpo", update: renderParticule, offset: 0 &#125;) &#125;function debounce(e, t) &#123; var a; return function() &#123; var n = this, i = arguments; clearTimeout(a), a = setTimeout(function() &#123; e.apply(n, i) &#125;, t) &#125; &#125;var canvasEl = document.querySelector(".fireworks");if (canvasEl) &#123; var ctx = canvasEl.getContext("2d"), numberOfParticules = 30, pointerX = 0, pointerY = 0, tap = "mousedown", colors = ["#FF1461", "#18FF92", "#5A87FF", "#FBF38C"], setCanvasSize = debounce(function() &#123; canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width = window.innerWidth + "px", canvasEl.style.height = window.innerHeight + "px", canvasEl.getContext("2d").scale(2, 2) &#125;, 500), render = anime(&#123; duration: 1 / 0, update: function() &#123; ctx.clearRect(0, 0, canvasEl.width, canvasEl.height) &#125; &#125;); document.addEventListener(tap, function(e) &#123; "sidebar" !== e.target.id &amp;&amp; "toggle-sidebar" !== e.target.id &amp;&amp; "A" !== e.target.nodeName &amp;&amp; "IMG" !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY)) &#125;, !1), setCanvasSize(), window.addEventListener("resize", setCanvasSize, !1) &#125;"use strict";function updateCoords(e) &#123; pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top &#125;function setParticuleDirection(e) &#123; var t = anime.random(0, 360) * Math.PI / 180, a = anime.random(50, 180), n = [-1, 1][anime.random(0, 1)] * a; return &#123; x: e.x + n * Math.cos(t), y: e.y + n * Math.sin(t) &#125; &#125;function createParticule(e, t) &#123; var a = &#123;&#125;; return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos = setParticuleDirection(a), a.draw = function() &#123; ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill() &#125;, a &#125;function createCircle(e, t) &#123; var a = &#123;&#125;; return a.x = e, a.y = t, a.color = "#F00", a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function() &#123; ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth = a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1 &#125;, a &#125;function renderParticule(e) &#123; for (var t = 0; t &lt; e.animatables.length; t++) &#123; e.animatables[t].target.draw() &#125; &#125;function animateParticules(e, t) &#123; for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) &#123; n.push(createParticule(e, t)) &#125; anime.timeline().add(&#123; targets: n, x: function(e) &#123; return e.endPos.x &#125;, y: function(e) &#123; return e.endPos.y &#125;, radius: 0.1, duration: anime.random(1200, 1800), easing: "easeOutExpo", update: renderParticule &#125;).add(&#123; targets: a, radius: anime.random(80, 160), lineWidth: 0, alpha: &#123; value: 0, easing: "linear", duration: anime.random(600, 800) &#125;, duration: anime.random(1200, 1800), easing: "easeOutExpo", update: renderParticule, offset: 0 &#125;) &#125;function debounce(e, t) &#123; var a; return function() &#123; var n = this, i = arguments; clearTimeout(a), a = setTimeout(function() &#123; e.apply(n, i) &#125;, t) &#125; &#125;var canvasEl = document.querySelector(".fireworks");if (canvasEl) &#123; var ctx = canvasEl.getContext("2d"), numberOfParticules = 30, pointerX = 0, pointerY = 0, tap = "mousedown", colors = ["#FF1461", "#18FF92", "#5A87FF", "#FBF38C"], setCanvasSize = debounce(function() &#123; canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width = window.innerWidth + "px", canvasEl.style.height = window.innerHeight + "px", canvasEl.getContext("2d").scale(2, 2) &#125;, 500), render = anime(&#123; duration: 1 / 0, update: function() &#123; ctx.clearRect(0, 0, canvasEl.width, canvasEl.height) &#125; &#125;); document.addEventListener(tap, function(e) &#123; "sidebar" !== e.target.id &amp;&amp; "toggle-sidebar" !== e.target.id &amp;&amp; "A" !== e.target.nodeName &amp;&amp; "IMG" !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY)) &#125;, !1), setCanvasSize(), window.addEventListener("resize", setCanvasSize, !1)&#125;; 这个部分可以自己按照洗好做一定的修改，会有不一样的效果。 添加不蒜子站点浏览数修改footer.pug，并添加如下行： 1234567891011script(async='', src='https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js') span#busuanzi_container_site_pv i.fa.fa-eye | 访问量 span#busuanzi_value_site_pv | 次 | span#busuanzi_container_site_uv i.fa.fa-user-md | 访客数 span#busuanzi_value_site_uv | 人 1hello world 由于pug对空格敏感，因此空格多少可以相对容易的调整。 添加clipboard.js(待完成)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新年折腾记---从Manjaro迁移到Arch]]></title>
    <url>%2Fposts%2F30549.html</url>
    <content type="text"><![CDATA[新的一年，热爱折腾的我当然是从折腾开始新的一年了…. 在经过了各位arch大佬和Gentoo大佬一年的洗礼…我终于决定从Manjaro切换到Arch Linux了（没十足的把握千万别学我，Manjaro其实是个非常好的发行版，其实我也没啥把握就是了….）。 准备迁移过程中考虑了两个问题： 我那快1800个软件包要怎么办 最初选择manjaro，主要是看中了manjaro对于内核切换的便利，以及方便的附加驱动的安装 有关第一个问题，可以通过备份一遍软件列表来解决，但是有关问题二，就要比较头痛了，习惯了方便的一键切换再反过来熟悉一下这种方式未免有点“仿古”的感觉… 那么正常来做迁移，首先需要备份一下软件列表，根据archwiki，我们需要用pacman导出一份列表，这里注意一下arch和manjaro的关系：manjaro的源，可以理解为大于arch的，也就是说对于arch的仓库，manjaro的一众自己的工具等都是“多余的”，但是介于我从aur也安了一部分包来看，aur和自己打包安装的那部分也要考虑进去。 因此在原有系统中执行： 1234#Qqen选项备份的是除了aur和自己打包安装的以外的包pacman -Qqen &gt; listQqen.txt #Qqem选项备份的是aur中的和自己打包安装的包，可以理解为Qqen的补集pacman -Qqem &gt; listQqem.txt 这两个列表保存在主目录就好，之后会用到。 然后还是基础系统的安装，直接base和base-devel两个包组外加iw、wpa_supplicant两个包解决，然后走一遍常规的过程。 这个时候我们再考虑一下，对于manjaro是在源里的软件，对于arch应该是如同aur里的，因为我也使用了相当多archcn的包，因此记得添加archcn源。 然后执行： 1234#获取arch中的存在的包pacman -S --needed $(comm -12 &lt;(pacman -Slq | sort) &lt;(sort listQqen.txt))#获取aur里的包yaourt -S --needed $(comm -12 &lt;(pacman -Slq | sort) &lt;(sort Qqem.txt)) 这时候剩下的包就是manjaro专有的了，如果你愿意的话也可以和我一样直接clone manjaro的那些包的源代码然后自己编译安装，这之后记得把相关的服务启动了，然后就大功告成了。重启一下看看是不是熟悉的界面又回来了。 后记： 貌似很多用arch的用户还在有着对manjaro的鄙视链啊…..但是有一点不得不说，就是该承认的非常用户友好的特性还是承认吧，都是linux用户互怼没啥好处。]]></content>
      <categories>
        <category>archlinux</category>
      </categories>
      <tags>
        <tag>archlinux</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怀念，甚想念，无法想念其一]]></title>
    <url>%2Fposts%2F32312.html</url>
    <content type="text"><![CDATA[春节第一篇2333，顺便还是要吐槽一下，rime真心难调教，实在是太难受了，换回搜狗了。 第一篇按照习惯我也不会谈技术反正就我那点知识也没有什么好拿出来讲的。因此今天还是打算随意写一写，毕竟写的开心就完事了。 然后呢…不知道大家有没有接到过类似的短信： 温馨提示:为守护三亚的蓝天白云，三亚全市严禁露天焚烧秸杆垃圾，三亚主城区及学校、医院、住宅小区等重点区域严禁燃放烟花爆竹，主城区公共场所严禁露天烧烤和祭祀烧纸，寺庙道观严禁燃烧高香。违者将予以处罚。请自觉遵守，共建生态文明三亚。—三亚市人民政府 嘛，倒是一下子透露了我过年的地点，不过呢，倒是也接到重庆市政府类似的短信。保护环境嘛，没办法的事。可是仔细想一想，好像没像小时候那样过年有些时日了。 回想小时候，每年必定是过年的前几天开始，采买、打扫、准备过年需要用到的一些小玩意儿这些一样没少过。也在过年前几天把家里的窗帘全部卸下然后清洗，再一个个装回去。也曾学着用五洁粉然后对着白色人造石的窗台一顿猛擦直到全部都变亮变白位置……虽然看着麻烦实际也确实麻烦，但是却是在多少年以后的今天令人感觉还能感受到年味的那些回忆。等到春节当天，中午出门去祖父母家，和兄长姐姐一起玩，去放点小鞭儿，冰天雪地的把自己裹成肉丸子到楼下的大平台上去“作妖儿”，往垃圾道里扔二踢脚什么的也是没少干。回来吃年夜饭，年年都是那几个菜色不变样却也是吃不腻，挺奇怪的。而后回家包饺子，看看电视。 那个时候赵本山老师还是春晚的红人，小品也不像现在这么尬，动不动就煽情动不动就歌颂。过去春晚创造了不少梗，歌手们也都是真实的实力派，每一样节目都让人觉得不会看腻，就连后半夜的节目都非常有意思。如果现在春晚都为了挽救收视率而接着一些东风并且请一些实力派的歌手也好演员也好回到那个舞台，就算看到那那些熟悉的面孔我也是觉得没有必要再看下去了，尬得要死的东西我为什么不做点自己觉得有意义的事情而非要和春晚死磕呢？ 我确实是相当恋旧，也知道所有东西不可能一成不变，不过还是觉得以前那种有过年气氛的过年只能活在记忆中实在是太可惜了。家里人都分散开了，今年也没能回去看祖母，祖父已经不在人世，很多事情不停地在变。越是想抓住想将那个那些个美好的时光据为己有，越是在发现它在眼前不断地消散的同时感觉心如刀绞。过去已经回不去了，一般都会在这个时间说“应该勇敢的面对未来”吧？但是老实说越是长大就越觉得一些事情不可思议，越觉得害怕面对未来，越想仅仅活在回忆中哪怕知道那些已经是梦，已经不可能在实现了。那么就没有办法了，总不能停下，未规划好的将来也需要考虑——不过不是出于个人意愿，而是出于“对自己负责”的责任。背负了那么多期望以及责任，既然已经背负起来了就不可能轻易地在将那些卸下去。责任就是责任，烙印一般的东西。 新的一年，愿各位身体健康，家庭和睦，工作顺利，学习进步。如果看完了我这么多牢骚话还没厌烦的话可以期待一下下一篇，不是牢骚也不是随笔，既然是技术博客那么技术类的不能少。新的一年希望自己能把坑填完，开个新坑，把日语复习一下最重要的是挂科的那几科一定要考过，真的不想再重修遭受那个罪了orz。]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建私人图床并使用]]></title>
    <url>%2Fposts%2F61150.html</url>
    <content type="text"><![CDATA[其实还是挺好用的？但是，由于图床挂掉，此文内容基本已废，将就看倒还可以。 如图所见！锵锵锵，自建了一个新图床。至于为什么这么做，主要还是因为腾讯云更改了收费及免费的条款，并且已有的vps不好好利用的话实在是资源浪费，所以决定自己建立一个算了。 VPS准备因为是要用作图库的VPS所以建议还是选择一个靠谱一些的服务商比较好，国内阿里云以及腾讯云都可以（毕竟学生优惠www）。如果可以的话建议选择storge instance之类的类型，特点是价格便宜并且硬盘空间很大。构架建议选择KVM，极度不推荐openVZ的机器。系统选择任意linux发行版都可以，既然都有能力弄主机，就别说连基础linux的操作都不会。 环境配置由于我们要使用的图床程序是chevereto ,按照官方文档的说明，使用LNMP是比较合适的。 这里选择LNMP一键包（其实也是我懒了）。LNMP那么容易配置就不细讲述了。主要需要注意的是phpMyAdmin的一些坑。 这个地方如果未选择相匹配的MySQL版本会导致无法远程连接到phpMyAdmin。因此请在选择版本时多加注意。另外安装完成时记得把/home/wwwroot/default/下的几个文件备份并清除。 安装chevereto这里我使用的是脚本安装方式，仍然是将脚本放到网站根目录即可。 注意：记得检查脚本的所有者以及权限 12ls -lash chmod a+x index.php 如果正常的话你会得到index.php的所有者和组为www，权限为775或者777。 所有步骤跟着向导就好，没有需要特殊注意的地方。 但是有一个地方需要注意以下，在新建mysql账户时请选择本机域（大概是这个，是localhost）这个地方以前在部署owncloud时就踩过，到现在才弄得比较明白。至此站点部署完毕。]]></content>
      <categories>
        <category>博客配套</category>
      </categories>
      <tags>
        <tag>archlinux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译安装gcc6.1]]></title>
    <url>%2Fposts%2F51180.html</url>
    <content type="text"><![CDATA[俗话说得好，一回生二回熟，但是时间长了也怕忘。离开了Gentoo那么久也懒得手动编译，但是偶尔也要复习一下为好。 源码获取这个应该是最简单的了，只要你能找到个镜像站，里面镜像列表都差不多有GNU，里面有诸多项目的源代码，gcc源码也不例外。怎么获取，请自己看着办。 展开源码正常操作 1tar xvf gcc6.1.tar.xz 定位到源码目录1cd gcc6.1/ 建立编译的工作目录： 1makedir build 建立工作目录的好处是可以避免编译过程中的中间文件污染源码（大概）。 查看编译选项先简单观察一下Archlinux的gcc编译选项 gcc 8.2.1 1234567使用内建 specs。COLLECT_GCC=gccCOLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-pc-linux-gnu/8.2.1/lto-wrapper目标：x86_64-pc-linux-gnu配置为：/build/gcc/src/gcc/configure --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c,c++,ada,fortran,go,lto,objc,obj-c++ --enable-shared --enable-threads=posix --enable-libmpx --with-system-zlib --with-isl --enable-__cxa_atexit --disable-libunwind-exceptions --enable-clocale=gnu --disable-libstdcxx-pch --disable-libssp --enable-gnu-unique-object --enable-linker-build-id --enable-lto --enable-plugin --enable-install-libiberty --with-linker-hash-style=gnu --enable-gnu-indirect-function --enable-multilib --disable-werror --enable-checking=release --enable-default-pie --enable-default-ssp --enable-cet=auto线程模型：posixgcc 版本 8.2.1 20181127 (GCC) gcc 7.4.1 1234567使用内建 specs。COLLECT_GCC=gcc-7COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-pc-linux-gnu/7.4.1/lto-wrapper目标：x86_64-pc-linux-gnu配置为：/build/gcc7/src/gcc/configure --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ --enable-languages=c,c++,lto --enable-shared --enable-threads=posix --enable-libmpx --with-system-zlib --with-isl --enable-__cxa_atexit --disable-libunwind-exceptions --enable-clocale=gnu --disable-libstdcxx-pch --disable-libssp --enable-gnu-unique-object --enable-linker-build-id --enable-lto --enable-plugin --enable-install-libiberty --with-linker-hash-style=gnu --enable-gnu-indirect-function --disable-werror --enable-checking=release --enable-default-pie --enable-default-ssp --program-suffix=-7 --enable-version-specific-runtime-libs线程模型：posixgcc 版本 7.4.1 20181207 (GCC) 前面部分是： 1--prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://bugs.archlinux.org/ 比较有用的部分只有 –prefix 选项。大致都可以看懂： 1--prefix=一级目录 --libdir=二级目录1 --libexecdir=二级目录2 --mandir=二级目录3 --infodir=二级目录4 --with-bugurl=URL 对于已经有了内置GCC的发行版，如果照搬选项则不是明智之举，因此按照个人需求将此处选项改为只定义一级目录即可。 1--prefix=$HOME/GCC-6.1]]></content>
      <categories>
        <category>archlinux</category>
      </categories>
      <tags>
        <tag>archlinux</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活好了，但是我想回到以前]]></title>
    <url>%2Fposts%2F21989.html</url>
    <content type="text"><![CDATA[睡前聊一聊上次像这样写文章大概是很久以前的事情了，那我为何突然想起来这些？用我自己的话来讲，现在我才一点点感觉到，越是接触新技术、新产品，愈是变得更孤独。当然了，学技术可以当做一个例外，但是，如果可以不与这些新玩意儿接触，从某种角度上讲确实不想接触。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android课设-蓝牙助手]]></title>
    <url>%2Fposts%2F37370.html</url>
    <content type="text"><![CDATA[课设制作思路非常简单，就是制作一个蓝牙助手 Bluetooth status helper课程设计设计缘由众所周知目前安卓机器都可以很简单的获取蓝牙状态。但是由于一些原因我所使用的HTC U Ultra在更新到了Android Oreo以后失去了查看蓝牙状态的功能。因此在本设计中打算借助外部方式实现这个功能 初步分析由于在使用Shizuku Manager时以及使用Brevent时发现可以通过扩展开发的方式调用部分系统API，这些API在一定程度上根据厂商的设计方式不同会无法直接调用或是被屏蔽掉。但是HTC在安卓5.0时代已经在系统中大量（完全）保留了原生Android的API，因此只要需要寻找这些接口的调用方式即可使用“被屏蔽”的功能。在手机实际使用过程中发现缺失的功能如下： 更改蓝牙可被发现状态 更改蓝牙可被发现状态的时长 (可选)查看的蓝牙列表 编写过程蓝牙权限的获取蓝牙权限的获取应该是整个项目最核心的部分。只有实现了能够检测蓝牙开启状态并请求蓝牙权限其余功能才能使用。在阅读官方文档时发现，在Android Oreo中，想要获取蓝牙权限，应该由四个权限组成：即两个位置权限，两个蓝牙权限。即： 1234567&lt;!--AndroidManifest.xml--&gt;&lt;!-- 添加蓝牙权限-开始 --&gt; &lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt; &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;&lt;!--蓝牙权限--&gt; &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;&lt;!--Android位置权限&gt;&lt;!--蓝牙权限添加-结束--&gt; 由于安卓新的安全机制，获取硬件的控制权限一般是视为危险行为（获取的权限为关键权限），因此需要动态调用权限申请以及权限的注册。 初始化蓝牙权限这一段直接上代码： 123456789101112131415161718192021222324252627282930313233343536setTitle("蓝牙助手"); &#123; if (savedInstanceState == null )&#123; bltAdapter = ((BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE)).getAdapter(); //查看设备是否支持蓝牙功能 if (bltAdapter != null )&#123; //查看蓝牙是否开启 if (bltAdapter.isEnabled())&#123; //若已经开启蓝牙则弹出一个提示已经开启 String notification = "蓝牙已经开启"; additional_inform="蓝牙开启"; information=logcat(information,additional_inform); Toast.makeText(MainActivity.this,notification,Toast.LENGTH_SHORT).show(); &#125;else &#123; //若未开启则弹出一个窗口请求开启权限 Intent enablebtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enablebtIntent, Constants.REQUEST_ENABLE_BT); &#125; &#125;else &#123; //当设备不支持蓝牙功能的时候点击按钮退出程序 AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setTitle("注意"); builder.setMessage("您的设备很可能不支持蓝牙功能"); builder.setPositiveButton("确定", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; finish(); &#125; &#125;); builder.show(); &#125; &#125; &#125; 关键点解释： 传感器一般是通过相应的Adapter来获取使用权，因此先注册BluetoothAdapter，并且方式为getAdapter()，获取系统的BluetoothService； 判断是否开启了蓝牙，如果未开启立即申请权限； 重写OnActivityResult()1234567891011121314151617181920212223242526@Override protected void onActivityResult(int requestCode, int resultCode,Intent data)&#123; super.onActivityResult(requestCode,resultCode, data); switch (requestCode)&#123; case Constants.REQUEST_ENABLE_BT: if (resultCode == RESULT_OK)&#123; additional_inform="蓝牙开启"; information=logcat(information,additional_inform); AlertDialog.Builder builder_welcome = new AlertDialog.Builder(MainActivity.this); builder_welcome.setTitle(""); builder_welcome.setMessage("感谢使用蓝牙助手！\n 这款工具面向部分ROM没有提供查看蓝牙状态功能的机型\n 如：HTC，LG\n 如果您的手机ROM拥有类似功能，您仍可尝试使用。"); builder_welcome.setPositiveButton("我知道了", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123;&#125; &#125;); builder_welcome.show(); Toast.makeText(MainActivity.this,"蓝牙已开启",Toast.LENGTH_SHORT).show(); &#125;else &#123; Toast.makeText(MainActivity.this,"蓝牙助手需要蓝牙权限才可以正常运行",Toast.LENGTH_SHORT).show(); finish(); &#125; default:super.onActivityResult(requestCode,resultCode,data); &#125; &#125; 这么写或者说这么改写的主要原因是蓝牙部分相当于使用了一个新的activity进行控制。 与之匹配的contants.java123public class Constants &#123; public static final int REQUEST_ENABLE_BT = 1;&#125; 这一段主要还是根据重写的onActivityResult()设定默认的request Code。 部分功能模块编写蓝牙开关1234567891011121314151617mswitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; if (isChecked)&#123; Intent enablebtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enablebtIntent, Constants.REQUEST_ENABLE_BT); Toast.makeText(MainActivity.this,"蓝牙开启",Toast.LENGTH_SHORT).show(); additional_inform="蓝牙开启"; information=logcat(information,additional_inform); &#125; else &#123; bltAdapter.disable(); Toast.makeText(MainActivity.this,"蓝牙关闭",Toast.LENGTH_SHORT).show(); additional_inform="蓝牙关闭"; information=logcat(information,additional_inform); &#125; &#125; &#125;); 日志查看模块主代码1234567891011goTO_log.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent log = new Intent(MainActivity.this,log_watcher.class); Bundle bundle = new Bundle(); bundle.putString("information",information); bundle.putString("time",time); log.putExtra("bundle",bundle); startActivity(log); &#125; &#125;); 查看Activity部分代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import android.content.Intent;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;public class log_watcher extends AppCompatActivity &#123; TextView log; TextView log_time; Button btn; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_log_watcher);&#123; setTitle("LOG"); Bundle bundle = getIntent().getBundleExtra("bundle"); final String[] information = &#123;bundle.getString("information")&#125;; final String[] time = &#123;bundle.getString("time")&#125;; log = (TextView) this.findViewById(R.id.logcat); log_time = (TextView) this.findViewById(R.id.logcat_time); btn = (Button) this.findViewById(R.id.log_clean); btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; time[0]="\0"; information[0] ="\0"; log.setText("\0"); log_time.setText("\0"); Toast.makeText(log_watcher.this,"日志已清除",Toast.LENGTH_SHORT).show(); &#125; &#125;); log.setText(information[0]); log_time.setText(time[0]); &#125; &#125;&#125; 传递log123456789101112131415private String logcat(String information, String additional_inform)&#123; information=information+additional_inform+'\n'; additional_inform="\0"; //log.setText(information); get_log_time(); return information; &#125; private String get_log_time()&#123; SimpleDateFormat sdf=new SimpleDateFormat("HH:mm:ss"); java.util.Date date=new java.util.Date(); time=time+"\n"+sdf.format(date); //log_time.setText(time+"\n"); return time; &#125; 设定可被发现时间如果认真研究过蓝牙的文档的话，不难发现蓝牙默认最长可被发现时间为300秒，并且在高版本Android上不能使用旧方法进行时间的延展，另外输入值的“null”以及“0”最终获取值并不相同，因此具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445cs_btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String _timeout = editText.getText().toString(); if(TextUtils.isEmpty(editText.getText()) )&#123;//判断输入是否为空 Intent dis_intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE); dis_intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300); startActivity(dis_intent); Toast.makeText(MainActivity.this,"设备参照默认最大时间:300秒设置可被发现",Toast.LENGTH_LONG).show(); additional_inform="设备可被发现，时间"+timeout+"秒"; information=logcat(information,additional_inform); &#125; else &#123; timeout =Integer.parseInt(_timeout); //若输入值不为空，采用安卓本身方法进行广播 if (timeout &lt;= 300 &amp;&amp; timeout != 0)&#123; Intent dis_intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE); dis_intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, timeout); startActivity(dis_intent); Toast.makeText(MainActivity.this,"设备目前已经可被发现，时间为"+timeout+"秒",Toast.LENGTH_LONG).show(); additional_inform="设备可被发现，时间"+timeout+"秒"; information=logcat(information,additional_inform); &#125; if (timeout &gt; 300)&#123; //若时间长于300秒，采用反射方式调用系统蓝牙可被发现的开关以达到延时目的 setDiscoverableTimeout(timeout); Toast.makeText(MainActivity.this,"设备目前已经可被发现，时间为"+timeout+"秒",Toast.LENGTH_LONG).show(); additional_inform="设备可被发现，时间"+timeout+"秒"; information=logcat(information,additional_inform); &#125; if (timeout == 0)&#123; Intent dis_intent = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE); dis_intent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 120); startActivity(dis_intent); timeout=120; Toast.makeText(MainActivity.this,"输入值为0。设备目前已经可被发现，默认时间为"+timeout+"秒",Toast.LENGTH_LONG).show(); additional_inform="设备可被发现，时间"+timeout+"秒"; information=logcat(information,additional_inform); &#125; &#125; &#125; &#125;); 时间高于300秒时方法重写12345678910111213public void setDiscoverableTimeout(int timeout) &#123; BluetoothAdapter adapter=BluetoothAdapter.getDefaultAdapter(); try &#123; Method setDiscoverableTimeout = BluetoothAdapter.class.getMethod("setDiscoverableTimeout", int.class); setDiscoverableTimeout.setAccessible(true); Method setScanMode =BluetoothAdapter.class.getMethod("setScanMode", int.class,int.class); setScanMode.setAccessible(true); setDiscoverableTimeout.invoke(adapter, timeout); setScanMode.invoke(adapter, BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE,timeout); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 另外一定要注意：一定要抛异常，否则编译时会报错 蓝牙扫描另外说起蓝牙，应该难点就是在广播及扫描部分，但是由于本人理解并不深刻因此可能会出现问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647scan_btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (bltAdapter.isEnabled())&#123; bltAdapter.enable(); &#125; if (bltAdapter.isDiscovering()) &#123; bltAdapter.cancelDiscovery(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123;//利用睡眠阻隔系统重启扫描服务，并处理异常 e.printStackTrace(); &#125; bltAdapter.startDiscovery(); &#125;else&#123; bltAdapter.startDiscovery(); &#125; Toast.makeText(MainActivity.this,"正在进行扫描...",Toast.LENGTH_SHORT).show(); Intent intent = new Intent(bltAdapter.ACTION_REQUEST_ENABLE); startActivity(intent); //扫描到了任一蓝牙设备 if(BluetoothDevice.ACTION_FOUND.equals(intent.getAction())) &#123; Log.v(TAG, "### BT BluetoothDevice.ACTION_FOUND ##"); BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); if(btDevice != null)&#123; Log.v(TAG , "Name : " + btDevice.getName() + " Address: " + btDevice.getAddress()); Toast.makeText(MainActivity.this,"Name:"+btDevice.getName()+"Address:"+btDevice.getAddress(),Toast.LENGTH_LONG).show(); &#125; else if(BluetoothDevice.ACTION_BOND_STATE_CHANGED.equals(intent.getAction())) &#123; Log.v(TAG, "### BT ACTION_BOND_STATE_CHANGED ##"); int cur_bond_state = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, BluetoothDevice.BOND_NONE); int previous_bond_state = intent.getIntExtra(BluetoothDevice.EXTRA_PREVIOUS_BOND_STATE, BluetoothDevice.BOND_NONE); Log.v(TAG, "### cur_bond_state ##" + cur_bond_state + " ~~ previous_bond_state" + previous_bond_state); &#125; &#125; additional_inform="设备进行扫描"; information=logcat(information,additional_inform); &#125; &#125;); 取消扫描1234567891011121314mCancel.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if (bltAdapter.isDiscovering()) &#123; bltAdapter.cancelDiscovery(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123;//利用睡眠阻隔系统重启扫描服务，并处理异常 e.printStackTrace(); &#125; &#125; Toast.makeText(MainActivity.this,"已取消",Toast.LENGTH_SHORT).show(); &#125; &#125;); 双击返回键退出这一段也是对返回键的执行进行重写： 12345678910@Override public void onBackPressed() &#123; long secondTime = System.currentTimeMillis(); if (secondTime - firstTime &gt; 2000) &#123; Toast.makeText(MainActivity.this, "再按一次退出程序", Toast.LENGTH_SHORT).show(); firstTime = secondTime; &#125; else&#123; finish(); &#125; &#125; 至于其他部分比如关于，非常简单没必要来说。 RES部分这部分最具有说服力应该只有这一段代码，方法是在res部分新建style.xml： 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt; android:shape="rectangle"&gt; &lt;solid android:color="#3dafeb"/&gt; &lt;corners android:radius="150dp"/&gt; &lt;stroke android:width="5dp" android:dashWidth="5dp" android:color="#77d5cf"/&gt; &lt;stroke android:width="10dp" android:color="#84ebe5"/&gt;&lt;/shape&gt; 顺便附上主activity的layout123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:accessibilityHeading="true" android:minHeight="142dp" tools:context=".MainActivity"&gt; &lt;Button android:id="@+id/changeStatus" android:layout_width="138dp" android:layout_height="51dp" android:layout_marginStart="15dp" android:layout_marginEnd="8dp" android:layout_marginBottom="148dp" android:background="@drawable/round_botton_2" android:text="change status" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintHorizontal_bias="0.484" app:layout_constraintStart_toStartOf="parent" /&gt; &lt;Switch android:id="@+id/_switch" android:layout_width="309dp" android:layout_height="38dp" android:layout_marginStart="8dp" android:layout_marginTop="44dp" android:layout_marginEnd="2dp" android:checked="true" android:showText="false" android:text="蓝牙" android:textOff="蓝牙关闭" android:textOn="蓝牙开启" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" tools:checked="true" /&gt; &lt;Button android:id="@+id/_scan" style="?android:attr/buttonStyle" android:layout_width="159dp" android:layout_height="160dp" android:layout_marginTop="132dp" android:background="@drawable/circled_button" android:fontFamily="sans-serif" android:lineSpacingExtra="10sp" android:text="SCAN" android:textAllCaps="false" android:textSize="30sp" android:textStyle="bold" android:typeface="monospace" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;Button android:id="@+id/goTO_log" android:layout_width="78dp" android:layout_height="34dp" android:layout_marginTop="72dp" android:text="log" android:textSize="10sp" android:background="@drawable/round_botton_2" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintHorizontal_bias="0.498" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toBottomOf="@+id/changeStatus" /&gt; &lt;EditText android:id="@+id/editText" android:layout_width="128dp" android:layout_height="54dp" android:layout_marginBottom="208dp" android:ems="10" android:inputType="number" android:textAlignment="center" android:textStyle="bold" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintHorizontal_bias="0.498" app:layout_constraintStart_toStartOf="parent" /&gt; &lt;Button android:id="@+id/mhelp" android:layout_width="42dp" android:layout_height="39dp" android:layout_marginStart="8dp" android:layout_marginEnd="8dp" android:layout_marginBottom="216dp" android:background="@drawable/question_button" android:text="\?" android:textStyle="bold" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintHorizontal_bias="0.0" app:layout_constraintStart_toEndOf="@+id/editText" /&gt; &lt;Button android:id="@+id/mCancel" android:layout_width="28dp" android:layout_height="28dp" android:layout_marginStart="8dp" android:layout_marginEnd="8dp" android:layout_marginBottom="160dp" android:background="@drawable/round_botton_2" android:text="×" android:textSize="10sp" android:textStyle="bold" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintHorizontal_bias="0.033" app:layout_constraintStart_toEndOf="@+id/changeStatus" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php入门到入土1]]></title>
    <url>%2Fposts%2F33109.html</url>
    <content type="text"><![CDATA[入土是不可能入土的 环境配置软件安装首先先安装PHP，php-fpm以及nginx。1pacman -S php php-fpm nginx 安装完成以后，记得配置好vscode对应的相关插件 注意一点，arch系的nginx配置虽然与其他发行版大同小异，但是初始可写目录不同。即初始化的目录虽然在/usr/share/nginx/html，但是实际上可写可读目录为/srv/nginx 配置文件修改安装完必要工具，修改配置文件。12345678910111213141516171819202122232425262728293031#位置/etc/nginxuser http http;worker_processes 1;event &#123; worker_connections 1024;&#125;http &#123; include mime.type; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; root /srv/nginx; location / &#123; index index.html index.htm index.php; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125; loaction ~ \.php$ &#123; fastcgi_pass unix:/run/php-fpm/php-fpm.sock; fastcgi_index index.php; include fastcgi.conf; &#125; &#125;&#125;]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>archlinux</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Firefox每夜构建食用指南]]></title>
    <url>%2Fposts%2F55829.html</url>
    <content type="text"><![CDATA[可能和你想的不大一样，这是个不算完善的方法，但保证好用。 Firefox下载及”安装“首先说明一下，archlinuxCN repo里面有每夜构建版本的Firefox，而且是四种语言版本:简体中文，正體中文，日本語，English(US)。但是这是我事后才知道的。话说回来，就算是使用了Mozilla官方的版本其实还是一个不错的选择。毕竟是预编译可执行文件，位置随意放置，比如我就放到了 opt下面。如果熟悉.desktop文件编写的话只要自己写个启动器就好，简单明了。这点还是要感谢一下Mozilla的打包方式，解压后的文件名统一就是Firefox。因此也可以做到多个Firefox版本共存。由于一些不可见光的原因，国内用户在百度搜索Firefox浏览器的时候会被redirect到火狐浏览器那里 好了你看到了，我把Firefox与火狐作了区分 为什么？因为你要是仔细观察就会发现不光是安装程序和协议，就连官网本身都并不相同（不只是语言），国内官网是被阉割过的。因此想要下载Mozilla软件请一定要认准Mozilla的官方地址，根据其性质是以org域名。传送门。Mozilla有CDN加持，国内访问速度尚可。接下来就是直接将页面拖到最低端，选择 Beta、Nightly、Developer Edition然后找到那个非常酷炫的nightly图标，点进去进行下载。Mozilla会在你进行下载的时候对系统进行判断，Linux下载后会得到一个以tar.bz2作为扩展名的归档文件。直接移动到/opt目录下面，获取root权限并解压：1tar -xvf firefox-nightly-版本号.0a1.tar.bz2 我这里写版本号诸君都能看懂吧，不要傻乎乎地复制粘贴。解压后会自动生成目录Firefox，此时在家目录下建立Firefox-nightly.desktop文件并填入以下内容（遵循X11标准，部分是KDE标准，DBUS部分可以不用理会）1234567891011121314151617181920[Desktop Entry]Comment[zh_CN]=Comment=Exec=/opt/firefox/firefoxGenericName[zh_CN]=GenericName=Icon=/opt/firefox/browser/chrome/icons/default/default128.pngMimeType=Name[zh_CN]=firefox nightlyName=firefox nightlyPath=StartupNotify=trueTerminal=falseTerminalOptions=Type=ApplicationX-DBUS-ServiceName=X-DBUS-StartupType=X-KDE-RunOnDiscreteGpu=falseX-KDE-SubstituteUID=falseX-KDE-Username= 这里需要注意一点就是我偷懒了，实际上的写法应该参考archlinuxCN的Firefox-nightly.desktop：1234567891011121314151617181920212223[Desktop Entry]Name=Firefox NightlyGenericName=Web BrowserComment[zh_CN]=浏览互联网Exec=firefox-nightly --class=FirefoxNightly %uIcon=firefox-nightlyTerminal=falseType=ApplicationMimeType=text/html;text/xml;application/xhtml+xml;application/vnd.mozilla.xul+xml;text/mml;x-scheme-handler/http;x-scheme-handler/https;StartupNotify=trueStartupWMClass=FirefoxNightlyCategories=Network;WebBrowser;Keywords=web;browser;internet;Actions=new-window;new-private-window;[Desktop Action new-window]Name=New WindowName[zh_CN]=新建窗口Exec=firefox-nightly --class=FirefoxNightly --new-window %u[Desktop Action new-private-window]Name=New Private WindowName[en_US]=New Private WindowName[zh_CN]=新建隐私浏览窗口Exec=firefox-nightly --class=FirefoxNightly --private-window %u 在这个写法中能够实现隐私窗口的调用，使得功能上更加完善。至此Firefox-nightly安装完毕。你以为这就可以满足我了吗？才怪。 自升级脚本编写升级模块下载模块很简单，如果通过Firefox下载浏览器新版本的话能够直接看到下载的链接，形如：https://download-installer.cdn.mozilla.net/pub/firefox/nightly/latest-mozilla-central-l10n/firefox-59.0a1.zh-CN.linux-x86_64.tar.bz2 。 那么之后就只需要替换版本号就可以了。但是也存在一个问题，就是如果版本号写死了，那么之后的升级操作通过执行脚本就显得很困难，而且最多只能保持在某一版本号这短暂的生命周期内。因此结合以前学习archlinux的PKGBUILD编写时某贴吧大佬的提示，将版本号全部使用 $pkgver 代替。根据bash的语法。此变量的声明应该在头部进行而且使用$声明的变量应该是有前部程序输出的。但是毕竟本人能力有限还不能够写出能直接被识别的变量名称（毕竟web地址特殊字符不少）。因此，思路是首先编写版本号文件pkgver.txt，在这个文件中输入版本号，借由cat命令执行输出并对之后变量的引用进行输入。因此,整个过程简化为：12345cd /opt_pkgver=$(cat pkgver.txt)wget https://download-installer.cdn.mozilla.net/pub/firefox/nightly/latest-mozilla-central-l10n/firefox-$_pkgver.0a1.zh-CN.linux-x86_64.tar.bz2tar -xvf firefox-$_pkgver.0a1.zh-CN.linux-x86_64.tar.bz2 #解压时会自动覆盖rm -xvf firefox-$_pkgver.0a1.zh-CN.linux-x86_64.tar.bz 权限判断模块上面我们讲了升级的基本操作：下载包，解压，删除。但是我们需要注意一点，我们在执行脚本时身份不是root，这样会容易造成麻烦。因此需要添加一个简单的身份验证模块,整个过程借由if语句:12345678if [[ $EUID -eq 0 ]]then cd /opt _pkgver=$(cat pkgver.txt) wget https://download-installer.cdn.mozilla.net/pub/firefox/nightly/latest-mozilla-central-l10n/firefox-$_pkgver.0a1.zh-CN.linux-x86_64.tar.bz2 tar -xvf firefox-$_pkgver.0a1.zh-CN.linux-x86_64.tar.bz2 #解压时会自动覆盖 rm -xvf firefox-$_pkgver.0a1.zh-CN.linux-x86_64.tar.bz;else echo &quot;Please run it use sudo or as root user!&quot;;fi 提示一点，千万不要忘记bash中if对空格敏感…还有就是分号不要忘记。 版本号模块正常来说的话，我们手动下载新构建的nightly时，Firefox会自动调用函数向上游发出请求来判断是否需要更新，但是我们自己的话就没有办法是用这个。因此我们需要手动构建一个。上面已经可以知道我们有一个名为 pkgver.txt 的额外的文件用来检测版本号。然后我们也很容易发现如果尝试下载旧版本的包时候会返回404。那么，这样思路就很明确了： 使用curl来获取http_code 使用tail，利用管道获取上面的返回值并剪切 使用一个循环来不断调用版本号的函数 那么可以利用以下代码：首先定义一个_link来存放链接1_link=https://download-installer.cdn.mozilla.net/pub/firefox/nightly/latest-mozilla-central-l10n/firefox-$_pkgver.0a1.zh-CN.linux-x86_64.tar.bz2 然后使用curl来获取http_code1curl -I -s --connect-timeout 5 $_link -w %&#123;http_code&#125; 此时应该可以正常获取到网页或者该文件信息了。使用管道：1curl -I -s --connect-timeout 5 $_link -w %&#123;http_code&#125; 定义到新的变量：1$_httpcode=(curl -I -s --connect-timeout 5 $_link -w %&#123;http_code&#125;) 夜间定时检测任务添加TODO： [x] 基础模块编写 [x] 发行版判断并可切换下载器 [x] 代理功能 [] 后续脚本优化]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>archlinux</tag>
        <tag>linux</tag>
        <tag>firefox</tag>
        <tag>firefox-nightly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fposts%2F16107.html</url>
    <content type="text"><![CDATA[Hello World！Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. hello world 原文Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: DeploymentPS:你可知道为了书写折叠区域的艰辛…结果发现就是如下一些代码结果我连next都升级了…配置文件全部需要重新搞。1234&lt;details&gt; &lt;summary&gt;&lt;!--折叠区域的提示词--&gt;&lt;/summary&gt; &lt;!--折叠的内容--&gt;&lt;/details&gt;这段原文当然是没有的啊混蛋！！ hello, againhello hexo！想了一想。还是打算把hello world.md搞回来。一来是一个项目（虽然称不上是项目）没有了hello world感觉很是让人失落；二来是想记录下自己创建博客的心路历程。参考了这篇以及这篇以后决定好好写一写这篇文章，改造一下hello world。 如果各位看的比较仔细的话会发现这篇文章的日期与我的第一篇文章创建日期刚好隔了一年时间。这一年时间，说长不长说短不短，只是一直感觉少了些什么。让人颇为失落。 因此这篇文章是一定要写了。 准确的说，我没有一个明确的建立博客的契机。当时只是在b站无意间发现了个视频，使用了比特萌出品的hexo便携版搭建博客，我最大的好奇是搭建到哪里去了。。。虽然后来才知道github给提供了gitpages服务，但是当时虽然用了蛮长时间github却什么也不知道。就这样，边看百度边摸索着把博客搭建了起来，学着适应了Windows7下面使用git bash.exe安装了VisualStudioCode作为markdown编辑器并且慢慢摸索着凭着一腔热血把Archlinux安装配置（一）这篇文章写了出来、换掉主题并且部署到github上。整个过程非常舒适（我其实没有实质性书写任何一点点hexo配置文件当时） 后来出现了一个问题，OpenSUSE42.1在深深让我感受到绝望以后我便完全叛逃到了Windows10 1509。怪也怪当时对UEFI下Linux的配置方式基本不知道。然后出现了一系列问题导致博客书写不能，初期忙于各种事情于是博客的事情就一拖再拖。 上面口水仗一般的简单讲了下我是怎么接触到hexo的 再见了我的高中生活～其实写了这么些再说这句话有点不是很合适了。不过这点确实是我开始决定开启博客书写的契机。 全部应该归功我的高中语文老师。与同年级其他班级的老师不大一样，我们班是有写积累本这个要求的。所谓积累本说白了就是一个本子，按照要求需要写一些观影感言什么的，这点与小学时的基本无异。区别是，有时候一些课内文言的翻译和重点词汇总结什么的也会被要求写在上面，另外有时会有一些话题类作文作为作业也是要求一并写在上面的。 不算自夸，如果阅读量不小的话，或者脑袋里稍微有点东西，观点类文章一千多字差不多半个小时就可以完成了。对于素质教育这点我们还是很有信心的，毕竟高中班上所有同学都是接受了了初中几乎纯素质教育升上高中的。这里稍微说一下我们的学校辽宁省实验中学北校。在我们入学时设有初中部高中部，而初中部的能力在当年是可以把全省其他初中吊着打的。尤其是比较讨厌的“第七监狱”，毕业生到高中以后的能力和我们初中培养出的根本没法比，现在的情况就让人唏嘘不已了。而高中部，设有一些班级专供中考失利没有考上学校本部：辽宁省实验中学 的人来就读，我便是其中一员这样的话基本上所有写作任务都不是什么难事。作为观点比较犀利的写手，我们更是有由课代表设立的“梦呓之肆”这种活动。每间隔一段时间会定下一个主题然后一群人来对这个观点发表一些评论并记述下来。那个地方，是在完全封闭生活中的我们的畅所欲言的地方，那里有思想的激烈碰撞，有面对一个事件不再一边倒似得评论而是全部客观分析的假设种种… 那是个至今还令人十分怀念的地方。 高中的书写习惯轻易没有办法改过来。一切从我个人厚度大约8mm的A4大小的积累本全部能够写满可以看出一些端倪。那就借此机会继续下去吧，形式改变了，但是我的思想还在。只要我还有时间还有这颗心，我就会继续写下去。 PS：喵～上面隐藏的部分说了我升级了next主题，这个以后会找时间来讲，但是现在就算了，板式比起旧版本还有很多不如意的地方。TODOs: next主题压缩优化 字体更换 music.js优化重构 部分样式表重构 图床迁移 配置文件更新 live2d模型配置迁移 music-aplayer迁移]]></content>
      <categories>
        <category>杂谈</category>
        <category>hello hexo</category>
      </categories>
      <tags>
        <tag>hello-word</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[youtuber木下ゆうか篇（一）]]></title>
    <url>%2Fposts%2F30769.html</url>
    <content type="text"><![CDATA[又一篇由于图床挂掉丧失乐趣的文章，但是不嫌弃的话，还是看看呗？这张图可是做了很久，但是想拿去的话help yourself!（反正我也没有备份了） 今天来谈一谈木下佑香，还是和往常一样分为两部分好了，我们先谈一些美好的，然后再把美好的东西一点点撕开来看，这才有趣，对吗。 youtuber木下ゆうか—are you still youself?都市人复杂生活中的开心果个人接触木下佑香比较晚，大概是2017年暑假那会儿。木下的视频给人最大的感觉就是欢快，一点不做作的小女生不但厨艺可以连胃口都不小简直是直戳我的萌点。声音可爱，长相好看而且和娇小体型形成强烈反差的进食量确实是让人欲罢不能。在繁重的都市人生活中。突然有一天跳出个这种小女生，那个人能狠下心来讨厌呢？况且平时生活的艰辛大家都懂，突然看到这个可以心无旁骛地吃东西，这个时候，这种欢乐和放松使人能够忘却很多烦恼。一边看她吐槽着食物，一边大口大口地咀嚼。光光是吃东西就能让人感到幸福，真的是太好了呢！ 印象最深的是，每天就算非常累了，也会在床上一脸傻笑地看她的更新，看她做东西吃东西仿佛自己有了女儿并且在幸福地咀嚼着自己亲手做的事物一样。论食物种类，除却作为广告的那些，都是很基本的和食。也有很多韩餐和中华料理，当然还有很可怕的奶酪地狱就是了。不过其他的都是小事不是么，最重要的是，她是那种笑靥如花的人。只要看着她就好像自己很幸福了一样。明明实际上年龄并不算小，但是看起来确实很年轻，这可能就是所谓的童心保存得很完整吧！ 黑历史知晓不得已但是令人自我厌烦我，真的非常喜欢木下佑香。在镜头前的她没有一丝做作，没有那种让我看到第一眼就反感的不得了的感觉，甚至可以说是我最喜欢的Youtuber。 然后现在出现了一个问题。由“爱好和想出名声”的想法，组件变成了为了“保持着出名而不得不继续”的样子之时，整个就变味了。商业性质倒是没有办法，毕竟不是谁都可以无时无刻用爱发电。但是一旦被捅出来有催吐行为就等于自杀无疑。 出于人类本能都对这种极其伤害身体的行为表示拒绝，但是此时也会使人深陷矛盾：如果你进行观看就从某种角度上是认同了她的催吐行为，使得她会“变本加厉”；但若是不进行观看的话等于她人气的下降，这样可能是无形中会加重她的催吐行为，这样的情况下不但没有起到正面效果，反而会因为她的行为与自己的自我厌恶形成恶性循环：在看到木下的脸时不自觉的会感觉到很惭愧但又想观看，因此，倒不如最后不再看了。 you are still yourself, but not the former one]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>木下ゆうか</tag>
        <tag>木下佑香</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[結城友奈は勇者である]]></title>
    <url>%2Fposts%2F11193.html</url>
    <content type="text"><![CDATA[勇者部五箇条勇者部六箇条 一、挨拶はきちんと二、なるべく谛めない三、よく寝て、よく食べる四、悩んだら相谈五、なせば大抵なんとかなる. . . . . . 六、人を助けるが、自分も幸せになる。 つづく]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>漫评</tag>
        <tag>结城友奈是勇者</tag>
        <tag>魔法少女</tag>
        <tag>泪腺崩坏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[archlinux安装配置(2)]]></title>
    <url>%2Fposts%2F60769.html</url>
    <content type="text"><![CDATA[上一次我们配置了基础系统，这一次我们需要进行进一步的配置以使这个系统能够进行日称使用，至少来讲，不能出大问题。我们在上次的安装中已经结束了基础环境的配置。但是仍然需要后续的一些准备。 后期处理 先不要弹出安装设备并重启 chroot 部分执行：1arch-chroot /mnt 进入已经安装完成的系统。此时，系统默认的shell程式应该是Bash。因此能够进行一些操作。 首先修改时区： 执行： 1tzselect 接下来跟着向导进行时区的修改。 然后执行： 1echo "主机名" &gt;&gt; /etc/hostname 来创建hostname。 并执行： 1nano /etc/hosts 修改hosts。 一个基础的hosts文件看起来应该是这样： 12345# Static table lookup for hostnames.# See hosts(5) for details.127.0.0.1 localhost::1 localhost127.0.1.1 你的hostname.localdomain 你的hostname 接下来修改locale: 1nano /etc/locale.gen 为了保险起见，locale.conf 我们不做任何更改。 找到en_US.UTF8 ，取消注释并执行： 1locale-gen 生成locale。 接下来执行： 1passwd root 来修改root账户的密码。 输入密码时不会有任何显示，这是一种安全措施，请不要慌张。 接下来我们需要安装引导程序，此时可以直接执行：1pacman -S grub os-prober efibootmgr 来安装相关的工具和程式。1grub-install --target=x86_64-efi --directory=esp分区 但是个人来讲更加推荐使用rEFInd程序代替之，一则是界面更加美观，二则是确实省心不少。需要安装rEFInd,执行：1pacman -S refind-efi 安装过程中会自动寻找操作系统的引导项(EFI)，无须担心。 1refind-install 接下来重启，并取出安装设备。从引导程序引导进入新系统。 重启后的操作重启后，应该可以直接看到提示输入用户名，键入：root，回车，并输入密码。登录到新系统。 注：我的个人建议是chroot下安装iw，dialog等工具，预防进入系统没网的尴尬。 桌面环境安装如果是稍微老一点的教程，可能会推荐先把显卡驱动什么准备好再安装桌面环境。但是我这里将直接讲解桌面环境的安装。因为基本上官方支持的桌面环境都是把我们需要提前安装的那些组件作为依赖来安装的。首先我们需要选择自己所需要的桌面环境。为什么我不在这里推荐一个？因为每个人喜好不同，各个桌面环境的体验也大不相同，需要知道自己的需求才能选择得相对舒服。 GNOMEGNOME是GNU基金会的亲儿子，全称The GNU Network Object Model Environment（GNU对地网络模型）。听起来高大上，但是其实是非常容易亲近和理解的。就是安装完能看到的整个视觉上的界面和底层诸多逻辑。在Archlinux想要安装GNOME非常简单。只需要执行： 1pacman -S gnome gnome-extra 即可完成GNOME全部套件的安装。如果仅需要基础的Shell那么只安装GNOME包组即可。 这里区分一个概念:包和包组简单的说，包就是单个软件，而包组从字面上理解就是一些包的集合。 KDE(KDE PLASMA)更新： 由于长达一年多用回了KDE，因此后文也会着重讲解KDE的基础配置。]]></content>
      <categories>
        <category>archlinux</category>
        <category>kde</category>
      </categories>
      <tags>
        <tag>archlinux</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么我屏蔽了知乎？]]></title>
    <url>%2Fposts%2F12984.html</url>
    <content type="text"><![CDATA[别的我不知道反正我是先在路由器里执行了如下命令……1iptables -I FORWARD -d www.zhihu.com -J DROP 说起来，今年好像是知乎成立的八周年的样子。那么我也姑且算是入坑知乎六年了。为什么我会选择退坑知乎，我想就算我不说，也会有好多人有相同感触——知乎已经俨然成为了培养故事创作能力的地方。 在这里，你可以重新塑造你自己的身份，你的经历。你也可以诱导其他人，避开矛头。这里已经是故事的创作中心、网络写手和键盘侠的集聚地，也是好多人仍然从中获取力量的地方。极其诡异，但是又极其有诱惑力。 为什么当年的我选择入坑知乎说到底，是因为百度知道实在是太不靠谱。同期的知乎，虽然内容很少但是答案含金量很高。草根大佬也能各显神通。但是，也存在一个问题，那就是因为圈子不大，所以好多问题，合法的、非法的都可以被讨论。正确的、错误的，无论怎样。那里的人们和我所听到的互联网才在中国开始流行的那几年的人儿一样，都有着别致的气息和绿林侠样的思维模式。 但是问题终究还是存在的。一个圈子会变大，会做大，是因为内容和氛围得到了其他人的认可。但是做大了。就必然需要更多的资金，更种方面的支持。知乎选择融资，与其本身而言，是有利的。知识变现，也成为那个时期的风潮。 但是，从那个时候我开始迟疑知乎用户爆发式增长的那几年，正好是我比较忙的几年，毕竟是全宿制高中的学生，周末放学回家也满脑子都是事情。但是，我，那几年确实是真正学到了很多东西。 全宿制带来的好处是在学校可以隔离一切，专心于自己想做的事情。正好那段时间也是我接触不到智能手机的几年，也是我深入玩儿Linux的几年。那段时间，能上网的功能机成为了我获取知识的主要渠道。不知道现在还有多少人记得那个红红的圆圈，浏览器多标签的开创者： Opera。要知道Ｊava的功能机也是可以使用３G网络的。那段时间真的是获取到了非常多的内容，知乎上每一个有关Linux的话题，问题，我都会关注。每个人的每一个字每一张图，直到现在我都记得。 混开源圈的终究没有那么多纯技术人员。每个人多少又会有书生气。而那段时间所看到的，无论是有关开闭源的讨论，发行版的讨论（Archlinux &amp; Gentoo,说多了怕引起圣战），甚至乎编辑器的讨论（Emacs &amp; Vim）都有着很是浓厚的技术色彩和宗教色彩。引人入胜。 但是也正是从那个时期我开始迟疑。我为什么要继续浏览着知乎的内容。不知道是从哪个时间点，对于技术的讨论嫣然成为了技术圈外的人装逼的资本。 沉下心来冷静思考有的时候包括操作系统在内不使用常规工具，其实说实话有那么一点点是为了能有装逼的资本。但是越来越深入才发现，所谓技术不也是实现一个个梦想么？我做不了很多的技术工作，那能够做的是什么？我所想寻找的。终究是一个容身之所，对等的，用自己的劳动来换取包容感。就算是翻译，我做的也只有这些，认同感其实并不是别人给予的。都是自我的心理安慰。每个字词的翻译，每个标点的调整，每次的最初根本不背父母理解的无偿志愿工作，说到底是为了寻求精神上的满足，为了缓解在学校也好在生活上也罢的心里压力。 我们的大学英语结课论文我们选择进行调查的是大学生志愿服务的心里、动机和渠道。不约而同的，回到了讨论当初困扰了我好久的心理状态上。后来，才发现其实志愿活动都是“利己性的”，无论愿不愿意承认，这个世界上从来都没有无私奉献。 但是压倒骆驼的稻草是什么上面说的，最多是我单方面认为需要像知乎上的大佬们那样，为了更强的自己而向上前进。我并不讨厌知乎。但是最终却被它激怒了。 那么究竟是什么能够让我如此愤怒？我想，可能原因其实并不在于知乎，根本是在于网络的使用者的无界限。 记得假期的时候有人在Biibili上进行引战，其直接后果是“国家队”的禁播。但这些并不是事情的全部，有人在知乎上利用伪技术骗取他人信任，从而成功地将所有关注点集中到一个无辜的消防员身上。其问题在于，那个假的消息之所以会为人信服，之所以会引爆所有人的情绪，关键在于知乎的匿名功能。 网络的匿名性本来提供给了使用者保护自己的便利，但是利用这些胡作非为确实已经导致了一系列的问题：社会、道德、伦理，凡是有人类出现的地方，只要匿名性存在，人们就会自相残杀。说到底人类的本质根本不是善，而是极度罪恶。人类，是恶的代名词。 不过话说回来，在这个世界上本来就是弱肉强食。弱者只有被吃掉的份，没有任何话语权。而为了成为强者，所有手段都是被默许的。变的是成为强者的方式和历代强者们，不变的永远是弱者会被宰割的事实以及成为强者的方式。 看到这里，你也许会认为我是个极度偏激的人，同时也是个有神论者。 我承认，我将会是你见过的很偏激的那些人之一，但是永远不是最和善的那个。如果说很久以前由于另一些原因我就开始嫌弃知乎。那么点燃引线的是国家队事件。而引爆我的则是之前无意中看到的一篇专栏。链接当然是没找到，但是，我仍然清楚地记得：那是篇博人眼球为目的的，狂妄的，过分偏激的文章。评论区更是聚集了我所见过的一切没有信仰的话语和肮脏的词汇、还有更多的自以为是的声音。 你问有没有反对的观点？我看到是有的，但是占据绝对少数而且被很肮脏的话辱骂着。 这里不得不提一点，我是有神论者。但是我同样信仰科学。 Je désapprouve ce que vous dites, mais je défendrai jusqu’à la mort votre droit de le dire.—François-Marie Arouet我不赞成你说的每一个字，但是你说话的权力我誓死捍卫。—伏尔泰 我认为这种大无畏的精神也许也可以用到现在的事情上。但是，前提是双方都能够拥有这样的权力。当其中一方想要以某种方式方式夺取另一方这种权力时，那么我可以认为在对等的前提下，这一方也不需要这种权利。 因此我可以认为，在匿名性的保护下大放厥词的人也是不需要我们尊重的。这种人本该让他自生自灭才好，问题在于害虫多了以后，已经到了无法会被净化掉的程度。那么，他所贬低的宗教，真的有那么可怕吗？在我看来没有。只有没有信仰的人才会惧怕宗教。前面我也说过我是有神论者，我相信所有的行为终究会被上天所看到。 然后我们来说说那个人。他的本意也许是好的，也只是为了清除掉借宗教名义敛财的人。但是他把矛头指向宗教却是不能令人赞同的。正如他自己所说的自己应该信仰科学。那么，“所谓科学”难道没有告诉你要对一切未知事物保持敬意吗？难道没有说过任何事物都具有两面性吗？不存在敬意的人，同样也是不被允许尊重的。确实，当宗教的行为比较极端是会引发一系列社会问题。但是宗教在现代，我想更多的是填补了人们由于那段时间内心出现的信仰空隙。 当一个一个人的心中没有任何信仰的时候，他不会对任何事物抱有敬意。他可以做任何事，他甚至可以诋毁其他一切思想。 当代国人所需要的就是信仰不是其他东西，当代国人最缺乏的就是信仰。信仰的力量有时候可以约束人的行为。而没有信仰，就可以胡作非为—–反正是在法律的空白区。对其他人造成的伤害都可以忽略不计——只因为那些话语是“合法言论”。 法律是用来管教人的，不可以用来约束人。 所以，我选择离开知乎这也许是个极其无奈的选择。我喜欢从前知乎的环境，每个人言论自由，但是会自觉避开敏感话题。所有人智商上线，且言之有物。 而不是现在，网络低龄化严重，经历可以编造，所有东西不再可信。那过去的时代也许不会再一次来临了。过度的低龄化势必会起到与发展相反的效果。小圈子所无法带来的利益是更大的圈子可以带来的。蛋糕做大，单也只不过是充入了更多的空气而已。果壳如此、36Kr如此、豆瓣如此、人人网如此，而如今，知乎也是如此。什么情怀不情怀的。只要一定程度上它自身能够盈利，那其他的就什么都不是。知乎在衰落，我们也是看得到的。有更多商业资本在运作的团队，下一个开始衰落的是谁呢？ 既然事已至此，那么我选择主动离开。无论是以前在那里有多么的欢乐、得到了多少感动、又重新振奋了多少次。过去是回不去的。那么，知乎，再见了。]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>知乎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[狂欢之夜，似乎内心也有些苦涩]]></title>
    <url>%2Fposts%2F34170.html</url>
    <content type="text"><![CDATA[今天不来谈技术，我们来说些柔软的东西。 就在几个小时前，6月17日这天，结束掉了。那么，几个小时前的你是正在为德国战车的失利而惋惜，为618购物节的前夜在狂欢，抑或是回味着所有一切的滋味，等待入眠呢？不论是哪种，今年的617，是不是有特殊的含义呢？ 记得小编还是个小屁孩时，对所谓的父爱真的是一无所知。在我眼中，那仿佛每时每刻都在向我发火的我的健壮的爸爸，真的如同恶兽一般。如此，直到高考结束。 有人说，成人礼是人蜕变的第一步，但是对我来说，成人礼一年多以后的高考成绩公布才是，同时也是感到极度心酸的时刻。记得那天他喝了很多的酒，却丝毫看不出醉意。一句“儿子你是好样的”瞬间让几年间因为我的成绩而被凿出了深壑的父子关系又完好如初。 从小学为了我不断陪我练习，到初高中住读每次回家时的严督，到后来陪我高考，陪我参加自招。。。到最后的时候，报道第二天的上午他和老妈来看了我，给我带了我已经睡熟悉的最喜欢的荞麦壳芯子的枕头。他几乎是不愿意离开，本来由于工作任务繁重已没有除了春节以外的其他假日，但是他硬是在我报道那两天来了重庆——横跨东北和西南飞了过来。回去的第二天又要坐在屏幕前赶着工期绘出图纸。临别时一句“这回我管不了你了哈”又让给我怎么作答，让我，一个男性，硬生生把眼泪吞回肚子里去，但又笑着：“你就放心吧！我又不是小孩。” …… 之前的离家根本不算是真正的离家。现在，K字头45个小时的距离才有着真真切切的感觉。 …… 无论最近的你是在奋战备考，还是在上交过毕设以后的小憩，还是继续为了理想而拼战到底，都一定不要忘记那个世界上第一爱你的男人。就算不能相互理解，也请相信这一天的到来。因为，你们是家人。 如果你恰巧记得昨天的真正含义，那恭喜你；如果你由于事务繁多忘却了，今天亦不算迟，记得要为父亲，用最发自肺腑的声音，最真实的声音，说一句： “父亲节快乐！爸你辛苦了！”。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018-06-09]]></title>
    <url>%2Fposts%2F50563.html</url>
    <content type="text"><![CDATA[天气炎热，本来说好的义诊人一共没来几个。微型网友见面会了解一下，虽然还是很舒服的。]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六月，我们]]></title>
    <url>%2Fposts%2F50906.html</url>
    <content type="text"><![CDATA[五月已经远去，儿童节已经过去了三天，如果没记错的话，毕业答辩也差不多在进行当中了。今天我们不来谈技术，来谈一谈更加柔软的东西。逐渐远离的五月，我们再犯一次五月病。有的时候就是这样，不愿意承认的感情，不想被希知的心情，就算加以掩饰，也会有被了解的一天。就算小编是大一的学生，有时候也不想承认，加入蓝盟对自己的改变是无法估量的。之所以一直更愿意谈谈技术，是自以为那样可以更好的隐藏起自己，殊不知，越是想隐藏，越是藏不住。 从面试到开始水群，开始认识了那些有趣的学长学姐们。无论是萌萌的七代目，还是现在帅气的八代目，意外不难相处的廖博士，强悍的巴学姐还是精明能干的姚学姐，还有完全不拘小节的（很好相处的）学长们（外校读研中）都令人印象深刻。都两次义诊的记忆更是没有办法忘却。“不计较，开朗，阳光甚至有点小猥琐”其实男人就应该是这样吧，就算我是男性仍然感觉到：这种魅力是没有办法抵挡的。记得有次问过七代目打算毕业以后怎么办，他直接了当回答说去工作。Emmmmm真是有趣的回答啊……本以为是考研还是什么的。好像本科毕业去读个硕士成为固有套路。虽然感觉会有些遗憾，嘛，都是个人的选择。 因此，直到上学期期末才渐渐发觉好像会错过什么。这种感觉，在这两个月开始的抛售物品中渐渐有了更强烈的感觉。记得高二的时候，也是这个时候，为了准备考试，所属社团的社长的毕业，一点没有去关注。去高三采购物资的时候，见到他本人倒也没有什么特殊感觉。直到一模完他大老远从南京回来看我们，那种难以言喻的感受才逐渐明朗了起来。是“不舍”。 就算到现在说实话，所有现任蓝客我也没有办法认全，毕竟平时接触到的也只有那些，屈指可数。求算事情堆积如山，如果有时间还是会上官网看看，看看大家积分的变化，看看自己的差距，就明白了还有个很长的路要走。默默地看着个人主页的变化，积分疯一样的增长。有时候时间比较充裕，转念登录后台想接一波老校区的单子顺便下去玩玩却几乎此次发现后台空空如野。有的时候会感觉，“这个人真的好高大”。但是，高大的是我们眼中的他们，真正的他们，我们亦不知晓。 从来都不是错觉，每个人的努力其他人都是可以感受到的。面对异常努力的人，那种仰慕之心丝毫不亚于小时候对于兄长和父亲的。正是因为这样，有的时候才希望替这个人承担他不应该承担的全部东西，不论他所背负的是什么，天真如孩童般希望一切美好都如期而至。但是明知自己什么都不是，有时候那样的念头却愈发强烈。越是无能为力，越是想要做些什么来进行改变。仅仅是因为“不想成为路人”。 毕业季，注定是令人五味杂陈的。即将进入新生活的喜悦，离别的伤感还有不舍，亦或是解脱以后的放松都将是多年以后最美好的回忆。即将离校的学长学姐们：恭喜毕业顺利，以后也请多多指教了。]]></content>
      <categories>
        <category>待修改</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>毕业季</tag>
        <tag>待修改</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro下生存报告]]></title>
    <url>%2Fposts%2F35108.html</url>
    <content type="text"><![CDATA[今天写这个不为别的，就为了现在在linux内核操作系统下生存暂时成功而进行记录。 前言说实话，现在用linux也快６年了，也算是对各个系统的特性有所熟悉了。但是，根本称不上是所谓大佬什么的。毕竟，虽然也能写一些脚本啥的，也算是会编程啥的，但是和一下子会好几门语言的其他人相比，我还是太弱了。很喜欢开源社区的氛围，有时候却不知道要做些什么好，没法维护一些项目就只好做做本地化工作了。传送门：gnome翻译组其实，现在的开源社区早已不是当时的开源社区了。我们在进入的时候，多少还有想着去回馈一下社区的开发者。而如今，伸手党遍地的现在，开源的各个项目早已是费力不讨好。氛围不在，过去的人也一个个离开，就连一些信仰纯正的人都不见了踪影。莫不如自己在博客上码码字，也算是对自己成长的回忆及立一个flag(笑)。总而言之，看看自己还能呆多久了。上面其实也是蛮早的截图了，后面由于一些原因更换为了KDE，但是KDE５的表现却着实不能让我这个以KDE４入门的人高兴起来，也许是我要求太高了也说不定．．．于是决定做一些简单的优化，毕竟电脑配置不算很好，但是能这么顺利地跑起来我就已经感激不尽了。具体优化策略和设置步骤放在这里：manjaro linux kde edition调教记录效果图如下: 感受其实，如果对于某些工具没有特殊的执着，使用哪个系统来工作都无可厚非。只不过是操作习惯有所不同。说实话，有人也曾经说过使用LINUX是一种自虐。老实说我无法反驳，但是，也用了这么长时间。现在这些配置文件就像是老朋友一样，也是舍不得再离开。 “那我为什么又说无法反驳？” 我个人觉得，linux虽然在服务器市场是一方霸主，虽然在个人桌面领域也逐渐受到重视。 但是使用体验仍然不够好。 就这一点，使得大量的小白用户最后又回到了Windows的怀抱。就算它蓝屏，就算它出了问题有多么难以修复，这么多年在个人桌面领域的投入：人力，财力，外加大量的基础设施建设，Office套件…使得微软和Windows不得不令人佩服。这点不得不承认，现有开源桌面环境是无法与之匹敌的。 “你这家伙是闭源商业狗” 如果你真的这么认为，那实在是太对不起了。我不否认我对于开源的热爱。这种人人都可以参与并改进的方式与我的生存理念是相合的。但是，你也无法否认，大量的闭源软件比如微软的办公套件，实际使用效率和稳定性明显高过现有开源解决方案。但这不能说明我有任何方向的倾向，我都会使用，支持，如果体验良好，我也会做推广。只不过与所谓“忠犬”不同，我只用我喜欢用的。毕竟，开源的LIBRE口号可不是白喊的，“人人都有选择的权利”。但是还有一点：少骂人了，你敢保证你使用的东西从硬件到软件到设计都是完全开源的？ 那为什么现在我又不愿意离开？ 我觉得原因很好解释：linux的自定义性可不是盖的。尤其是LFS系的发行版,包括Archlinux,Gentoo Linux等（注意了,LFS本身并不是发行版）。良好的文档和手册使得在熟悉了以后使用很是便利，外加桌面环境带来的良好体验，以及作为国内用户最重要的本地化软件的上线，都使得现在在一部分硬件资源吃紧的电脑上，linux的表现要明显好过Windows，不能说是吊打，但是日常使用方面还是体验不可同日而语。老实说，像我这种工科类的学生，平时也会大量使用专业软件，包括SolidWorks,AutoCAD等纯种闭源商业软件。但是这并不影响我花费更多的时间在linux下。双系统只是为了专业软件，平时另一个系统也只是放在那里，打入冷宫。 开源与闭源，我的个人经历开源与开源组织；闭源与商业化组织开源的好处，弊端；为什么仍有人选择开源作品未完待续…]]></content>
      <categories>
        <category>待填坑</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>manjaro</tag>
        <tag>生存记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js从入门到坚持（转载）]]></title>
    <url>%2Fposts%2F38757.html</url>
    <content type="text"><![CDATA[本手册的使用说明： 按着顺序看就应该能懂，并且少走弯路 👉👉👉 后面的链接为主要内容 更多 后面的链接为补充内容，不一定需要看 ⚠️ 的意思是「需要注意的是」 🙈 的意思是「随便看看不用记，需要的时候再翻」 ‼️ 的意思是「有更正」 链接主要来自 MDN，比 W3school 之类的强多了，学习 Web 技术都尽量看 MDN 的资源 (最好也看看英文的，顶部可以切换语言，我发现有的中文翻译的专有名词有点奇怪，还不给英文原词) 基础语法与 DOM 操作本阶段：我想留住头发。能进行绝大多数页面交互，包括响应用户操作、编辑界面元素、AJAX 数据交换。 JS 是什么? 如何使用?一门 动态类型、面向对象 的 解释执行 语言。是唯一 可以在浏览器上直接执行 的程序设计语言。 JS 几乎可以做任何事，是现在使用最广泛的程序设计语言之一，同时也是 GitHub 上最活跃的语言 (GitHut）。本阶段主要学习的是 JS 在前端开发中的使用。 JS 可以使用 &lt;script&gt; 标签内嵌在 HTML 内，或链接引入 JS 脚本文件。12345&lt;script&gt; alert("hello, world");&lt;/scrpit&gt;&lt;script src="script.js"&gt;&lt;/script&gt; 学习 JS 一个方便的方式是使用浏览器的 开发者工具-&gt;Console (控制台)，Console 内的代码将被直接求值。开发者工具内还能显示错误信息 (MDN 什么地方出了错？) 与设置断点 (Chrome断点调试) 来帮助调试。 2015 年 JS 迎来了一次重大语法更新 ES6。ES6 中新增的内容大多与入门无关，新增的语法糖将会随着各部分内容一并介绍。 更多：MDN 什么是JavaScript？ 基础语法JavaScript 从 Java 中借用了大部分语法，但也受到 Awk，Perl 和 Python的影响。 JavaScript是区分大小写的，并使用 Unicode字符集。在JavaScript中，指令被称为 statements，并用分号 ; 分隔。ECMAScript 规定了如何自动插入分号来结束语句。但是，建议随时添加分号来结束语句，以避免可能的副作用。 注释 在代码内的解释性文字，不会被执行。JS 的注释语法与 C++、Java 等语言相同。1234567// 单行注释/* 这是一个更长的, 多行注释*//* 然而, 你不能, /* 嵌套注释 */ 语法错误 */ 变量变量就是用于 存放数据的容器。 👉👉👉 MDN 变量 ES6 中新增了关键字 let, const 来申明变量与常量，与 var 差异不大，可以在第三阶段「JS 的并发编程及其他语法」中学习。 数据类型 变量存放着数据，而数据有不同的类型。数据类型的概念从程序语言使用的角度来讲，就是能对一个变量所进行的操作的类别。 变量存储不同类型的数据时，能进行的操作也不一样。 JS 有 6 种 原始数据类型 String, Number, Boolean, Symbol, null, undefined (Symbol 为 ES6 新增类型) 与 Object 对象类型。对象类型是一类类型的统称，它们各自能进行不同的操作，JS 中常见的对象类型有 Array, Error, Date 等。关于对象类型可以在第二阶段「JS 的面向对象」中学习。(‼️ Math 是一个对象不是类型) ⚠️ JS 中未赋值的变量 (包括函数参数) 值都为 undefined。 使用 typeof 运算符可以获得变量的数据类型，有 “string”, “number”, “boolean”, “object”, “function”, “symbol”, “undefined”。typeof 的运算结果为 String 类型。⚠️ typeof null 的结果为 &quot;object&quot;。⚠️ 在 JS 中函数 (Function) 也是一种类型 (变量值) 但不是「数据」类型。 更多：MDN 语法和数据类型 字符串👉👉👉 MDN JavaScript中的字符串 ES6 中新增了反引号 ` 包围起来的字符串，称为 模板字符串模板字符串中插入变量不再需要用 + 将字符串与变量连接起来，而是直接在模板字符串内使用 ${expr} 嵌入：1`Hello $&#123;name&#125;, nice to meet you!` 更多：MDN 有用的字符串方法MDN String 数组👉👉👉 MDN 数组 ES6 数组的解构赋值1234567891011121314var [a, b, c] = [1, 2, 3];// a = 1, b = 2, c = 3var [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3var [ , , third] = ["foo", "bar", "baz"];third // "baz"var [x, , y] = [1, 2, 3];x // 1y // 3 左值 (被赋值的变量) 按照对应位置提取右值数组中的值。右值为变量而不是字面量时也可解构：12var array = [1, 2, 3];var [a, b, c] = array; ES6 剩余 (rest) 语句 与 扩展语句 🙈 语法均为 ...variable，区别在于 variable 是左值还是右值。事实上，剩余语句在函数参数中使用更为广泛。见 基础语法-&gt;函数数组的解构赋值中可以使用剩余语句来将没有对应左值的余下右值放入一个数组中：12var [a, b, ...arr] = [1, 2, 3, 4, 5];// a = 1, b = 2, arr = [3, 4, 5] 扩展语句可以将数组展开，在数组中的应用是合并数组与元素等：12var merged = [...array, "abc", ...arr];// merged = [1, 2, 3, "abc", 3, 4, 5] 更多：MDN Array 运算符算数运算与比较运算 👉👉👉 MDN 数字和操作符 ES6 中新增了幂运算，如 a 的 b 次方 a ** b ⚠️ JS 对于非 Boolean 值的比较运算，以及非 Boolean 值到 Boolean 值的转换非常混乱与诡异，是 JS 语言中最大的败笔。遇到上述两种情况时，务必先查阅以下链接，及代码片段： 🙈 真值表 Oh My Dear JavaScript123456789101112131415161718192021🙈 // Falsyif (false)if (null)if (undefined)if (0)if (NaN) // Not A Numberif ('') // emplty stringsif ("") // emplty strings🙈 // Truthyif (true)if (&#123;&#125;) // Objectsif ([])if (42)if ("foo") // non-empty stringsif (new Date())if (-42)if (3.14)if (-3.14)if (Infinity)if (-Infinity) 逻辑运算 名称 运算符 描述 逻辑与(AND) expr1 &amp;&amp; expr2 如果 expr1 能被转换为false (falsy 值)，那么返回expr1；否则，返回expr2。 逻辑或(OR) `expr1 expr2` 如果 expr1 能被转换为true (truthy 值)，那么返回expr1；否则，返回expr2。 逻辑非(NOT) !expr 如果操作数能够转换为true (truthy 值) 则返回false；否则返回true。 ⚠️ Truthy 值与 Falsy 值可查阅以上代码。⚠️ 对于 Boolean 值逻辑运算符的作用与数学中相同，但对于非 Boolean 值，JS 的逻辑运算符能起到条件判断的作用，如下🙈：123456789101112var action = input || "default"; // 若 input 为 truthy 则将 input 的值赋给 action， // 否则 action 赋值为 "default"// 作用同于var action = input ? input : "default"; // 条件运算符见下// 以及if (input) &#123; var action = input;&#125; else &#123; var action = "default";&#125; var a = b &amp;&amp; c; // 若 b 为 falsy 则 a = b，否则 a = c 条件运算符 condition ? expr1 : expr2若 condition 为 truthy，则对 expr1 求值并返回，否则对 expr2 求值并返回。 更多：MDN 表达式和运算符 流程控制流程控制是程序设计的最根本的内容，学习完本章内容后，理论上已经可以写出任何功能的程序，只是效率和可读性上有所欠缺。 语句与语句块 在 if 条件语句，与 for 及 while 循环语句中，判断或循环条件后的多条语句需要用大括号 {} 包围起来，称为语句块：123456if (true) &#123; alert("这些"); alert("语句"); alert("都会"); alert("执行");&#125; 而不使用 {} 时，只有判断或循环条件后的第一条语句受到该流程控制语句的作用：12345var count = 5;while (count--) alert("这条语句会重复执行");alert("这两条只");alert("执行一次"); 条件语句 JS 有两种条件语句：if…else 和 switch 👉👉👉 MDN 条件语句 ⚠️ 如果某条 case 语句后没有 break，通过该 case 条件的流程会穿过其它 case 执行直到遇到 break 语句。 循环语句 JS 有 5 种循环语句：12345678910// 这三种在本节学习for (initialExpression; condition; incrementExpression) statementwhile (condition) statementdo statement while (condition);// for...of 可在更多链接里学习，这是 ES6 新增的语法for (variable of array) statement// for...in 需要在学习 JS 的面向对象之后理解for (variable in object) statement 👉👉👉 MDN 循环吧代码 ⚠️ for 语句后如果有使用到循环变量 (在循环条件使用的变量) ，循环变量的值是第一个不满足循环条件的值，而不是最后一个满足循环条件的值。 更多：MDN 循环和迭代 函数🙈 👉👉👉 MDN 函数-可复用代码块 函数的定义与调用 我们先来看看数学中的函数 $F(x,y)=x^3 + y + 3$。它用 JS 函数写出来是这样：123function F(x, y) &#123; return x ** 3 + y + 3;&#125; 其中 function 是申明函数的关键字 F 是 函数名，与变量命名规则相同，可省略 (x, y) 是 参数列表，由逗号分隔，没有参数时括号也不能省略 大括号 {} 包围的内容称为 函数体，是调用函数时执行的代码，可有 0 到多条语句 return 是函数的返回语句，意味着函数调用后输出的值。无 return 语句意味着不返回值 (准确的说是返回 undefined) 使用它就如同数学中的 $Let \ \ a = F(2, 3)$：12var value = F(2, 3);// value 为 14 但程序语言的函数跟数学中的函数依然有着很大差别，例如程序语言的函数的参数不一定是数字 (如 alert(message) 参数是 String)，甚至可能没有参数；程序语言的函数也不一定会返回数字 (如 String#split(separator) 返回 Array)，甚至不会返回值。(# 不是 JS 的操作符，详见 DOM 操作-&gt;初窥对象) 那么没有参数或返回值的函数有什么用呢？如同前面链接里的 draw() 函数，它们提供的是 重复使用一个流程的便捷方法。 函数返回值 👉👉👉 MDN 函数返回值 将函数赋值给变量 这是 JS 中最灵活，对于初学者也最为之迷惑的特点之一，函数本身是一个变量值 (Lambda 函数)， 函数本身可以赋值给任何变量 ，乃至将函数作为函数参数、函数返回另一个函数：123456789var f = F; // 上面定义的 Ff(2, 3); // = 14function produceFunction(welcome) &#123; return function(name) &#123; return `$&#123;welcome&#125;, $&#123;name&#125; !`; &#125;&#125;produceFunction("Long time no see")("Sandy"); // "Long time no see, Sandy !"" 前面链接中的将匿名函数赋值给一个变量，实际上就是产生了一个 函数类型 的变量值，然后这个变量值被赋值给了变量。任何函数类型的变量值，都可以通过函数调用操作符 () 调用。 即时执行函数 (IIFE) 🙈 只要将函数的定义用括号 () 包围，就可以立即用函数调用操作符 () 调用：1234(function(name) &#123; var nothing = 0; return "Hello " + name;&#125;)("Vincent"); // "Hello Vincent" 使用 IIFE 的一个好处就是，IIFE 内的名称不会污染到外部乃至全局 (global)。 箭头函数 🙈 ES6 新增语法 MDN 箭头函数 不定参数函数 🙈 定义函数时，参数列表中的各个参数叫做 形参 (Parameters)；调用函数时，传递给函数的各个参数叫做 实参 (Arguments)。形参与实参的个数不一定相同。对于有确定最大参数个数的函数，参数列表里形参的数量可以与最大参数个数相等，实参数量不足时，靠后的参数值为 undefined；而对于有不确定个数参数的函数，可以使用 剩余语句 (见 基础语法-&gt;数组) 来接受不定个数的参数：1234function getRestArguments(first, ...rest) &#123; return rest;&#125;getRestArguments(1, 2, 3, 4, 5); // [2, 3, 4, 5] 同时，可以使用 扩展语句 来将数组展开为函数参数：12var array = [6, 7, 8, 9];getRestArguments(...array); // [7, 8, 9] 更多：MDN 函数 DOM 操作文档对象模型 (Document Object Model) 是以面向对象方式描述的文档模型，利用 DOM 可以对整个网页界面进行任何操作。 初窥对象⚠️ 不是去盯着男票/女票看！禁止虐狗(我)！ 泛指的对象其实是没有实际意义的抽象名词，可以用任何一个词替代，例如东西、玩意 、鬼东西、🐔儿玩意。前面使用的所有变量值都是一个对象，因为 它们都是一个东西 JS 将一切都视为对象。(所有对象都有名为 toString() 的方法，除了整数需要加括号才能访问外，其它任何量都可以直接访问，3.14.toString()。) 至于为啥原始类型变成对象了，多半是借用的 Java 中原始数据类型与包装类的概念 (Java中基本数据类型和包装器类型的关系)。 每个对象(东西)都可能有属于它的东西，称为 属性，例如数组的长度 Array#length，文档的 body 结点 document.body。(# 不是 JS 的操作符，它的意思是某种类型都有某个属性，实际使用时是对一个对象使用 . 操作符，如 [1, 2, 3].length。) 每个对象(东西)也都可能拥有某些功能，称为 方法，例如在数组末尾添加项目 Array#push(item), 在文档中用选择器查找结点 document.querySelector(selector)。 访问对象的属性与方法需要使用 成员访问操作符 .。 原生 DOM 操作🙈 👉👉👉 MDN 事件介绍 🙈 👉👉👉 MDN 操作文档 使用 JQuery最流行的 DOM 操作库有 JQuery, Zepto.js 等，它们封装了基本的 DOM 操作，提供更简练的语法，进行更高效的开发。 👉👉👉 W3school JQuery 只需要学习 入门、HTML、遍历、AJAX 即可。动画由于现在移动端的性能需求，更多通过 CSS 来实现。 大体上 $(selectors) 的用法与 document.querySelector(selectors) 相同。 JS 的面向对象本阶段：苍茫的前端是我的爱。更加庞大的 Web App 开发，以及使用主流前端框架 (React, Vue 等)。 JS 的并发编程及其他语法本阶段：我想深♂入了解 TA 的全♀部，以及使用 JS 后端开发。]]></content>
      <categories>
        <category>转载精品</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>教程</tag>
        <tag>转载文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[drcom-python CQU-HX]]></title>
    <url>%2Fposts%2F2868.html</url>
    <content type="text"><![CDATA[使用说明转载信息：这个文件是在drcom-python版本基础上进行制作的使用时请严格按照说明来操作否则出现问题概不负责请勿用作商业用途 配置方法请先搜索并安装python2.7.x版本传送门（ python2.7.14） 然后根据您的操作系统选择安装然后打开python文件就是 link.py ，配置校园网用户名和密码再把它放到个人文件夹（比如Administrator）下这样就完成了！！！如果嫌麻烦，把我提供的 link.bat 也放到个人文件夹下然后每次只要双击link.bat就可以了！！！用这个方法可以避开开热点的检测，超好用，配合win10的开热点工具简直美滋滋github地址]]></content>
      <tags>
        <tag>drcom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[archlinux安装配置(1)]]></title>
    <url>%2Fposts%2F7521.html</url>
    <content type="text"><![CDATA[安装之前请确认： 1.你安装arch Linux的目的是什么。是学习Linux吗？是为了装酷，还是寻求刺激？2.你将安装它到哪里？是你正在使用的电脑上，是一个即将淘汰的旧电脑上，亦或是虚拟机中？3.你是否了解它的安装方式？还是你打算一步一步学习如何安装？4.你是否了解它的优点和缺点？如果你并不不了解，你是否能承担风险?我并不是要打消你尝试arch Linux的热情，但是arch Linux激进又高频的更新却几乎使所有使用过它的人印象深刻。频繁更新所带来的新功能和其带来的极不稳定性也为人所诟病。如果你可以在终端下面对字符愉快的玩耍，那么你使用arch Linux将不会有任何问题，但是，如果你是一个新手，那么你将需要一点时间，耐心和解决问题的能力来安装并使用arch Linux。 准备安装 1.你可能需要确认你要安装位置，如：实体机，虚拟机，为此你将可能要额外准备例如软碟通或UUI这样的工具来帮助你将镜像文件写入U盘中2.如果你的主力系统是Windows xp或Windows 7你可以正常的准备一定的空白磁盘空间，如果是Windows8/8.1/10，你则需要额外了解UEFI模式下Linux操作系统的安装方式 开始安装(基础系统) 首先，你需要设置你的电脑从你的可引导设备（也就是你在前一步中的U盘）在arch的引导菜单中，你要选择boot x86-64那项以安装arch Linux，在经过短暂的加载后你将进入Linux的shell模式下。注意：请确保你有网络连接如果你拥有有线连接或被Linux内核原生支持的无线网连接，那么恭喜你，可以继续安装了首先要确保网络连接的速率 1ping -c 3 www.baidu.com 如果速率良好，则可继续安装。如果速率不佳则要执行： 1nano /etc/pacman.conf 在文件中用快捷键 1^w 找到含wget那行并去除行前的“#”号，然后执行 1^o 以写入改动，并用 1^x 来退出nano。 磁盘准备在这里我们选用cfdisk图形化分区工具在shell界面执行 1cfdisk 在打开的界面选择磁盘类型 如果你是用的是已经有操作系统的计算机,请确认你的操作系统使用的磁盘类型通常win7及以下版本的Windows使用的是有诸多限制的mbr的类型,即”dos”;而win8及以上为gpt格式的磁盘这里就先选择传统格式DOS类型 选择GPT类型,回车按照传统的分区方式,将分区分为/,/home,和efi分区. 注意一定要将/分区选为Bootable然后选择write选项将改动写入磁盘并退出接下来执行 1mkfs.ext4 /dev/sdYX 1.这里Y代表磁盘的编号,通常以小写字母a,b,c,d…表示2.X表示分区编号,通常以数字1,2,3…形式表示3.在本文中sda1为/分区,sda2为swap分区,sda3为/home分区4.这里涉及了efi分区。由于这个分区的特殊性，如果是双系统则不需要另外建立，如果是Archlinux单系统就需要建立一个格式为fat32的分区用来储存efi文件。 因此执行 12mkfs.ext4 /dev/sda1mkfs.ext4 /dev/sda3 然后执行 1mount /dev/sda1 /mnt 挂载分区到挂载点/执行 1mkdir /mnt/home 创建/home目录并执行 1mount /dev/sda3 /mnt/home 来挂载sda3分区到/home目录创建目录/boot/EFI,并将efi分区挂载上去 12mkdir -p /mnt/boot/EFImount /dev/sda2 /mnt/boot/EFI pacman配置首先配置软件源 1nano /etc/pacman.d/mirrorlist 寻找含有China一行的软件源并去掉句前的＃号,一般启用2,3个源即可 Linux内核的操作系统大部分的调整都是通过修改配置文件进行的有诸多选项是可进行选择的,而大部分配置文件会预先给出选项,因此只需删除句前的＃号即可启用选项,而保留＃的哪一航被称为”注释掉了” 最后执行 1pacman -Syy 强制刷新软件源.至此,包管理器pacman配置完成 基础系统安装执行 1pacstrap -i /mnt base base-devel 来安装基础系统待安装完成,使用 1fstab -t LABEL -p /mnt &gt;&gt; /mnt/etc/fstab 添加分区的UUID标记。UUID之后也可能会无数次用到遇到。需要特殊注意。 更新：fstab使用UUID虽然是推荐的但是很是麻烦，因此个人建议个人使用时候使用卷标即可。 记得执行： 1cat /mnt/etc/fstab 来查看内容是否正确生成。 至此，基础系统安装和准备全部完毕。]]></content>
      <categories>
        <category>archlinux</category>
      </categories>
      <tags>
        <tag>archlinux</tag>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
